{
    "docs": [
        {
            "location": "/", 
            "text": "Atlas.Orm\n\n\n\n\nNo annotations. No migrations. No lazy loading. No data-type abstractions.\n\n\n\n\nAtlas is a \ndata mapper\n\nimplementation for your \npersistence model\n (\nnot\n your domain model).\n\n\nAs such, Atlas uses the term \"record\" to indicate that its objects are \nnot\n\ndomain entities. Note that an Atlas record is a \npassive\n record, not an \nactive\nrecord\n; it is\ndisconnected from the database. Use Atlas records as a way to populate your\ndomain entities, or use them directly for simple data source interactions.\n\n\nAtlas is stable for production use. Please send bug reports and pull requests!\n\n\nRationale\n\n\n(Or, \"Why does Atlas exist?\")\n\n\nI wanted an alternative to Active Record that would allow you to get started\nabout as easily as Active Record for your \npersistence\n model, and then refactor\nmore easily towards a richer \ndomain\n model as needed.\n\n\nUsing a table data gateway for the underlying table Rows, then composing them\ninto Records and RecordSets via a data mapper, does the trick. As you begin to\nneed simple behaviors, you can add them to the Record and RecordSet persistence\nmodel objects. (Rows do not have behavior.) Your domain logic layer (e.g. a\nservice layer) can then use them as needed.\n\n\nHowever, per \nthis article from Mehdi Khalili\n, the target end-state for\nyour modeling should eventually move toward \"Domain Model composed of\nPersistence Model\". That is, the domain Entity and Aggregate classes might use\ndata source Records and RecordSets internally, but will not expose them. They\ncan manipulate the persistence model objects internally as much as they wish.\nE.g., an Entity might have a \ngetAddress()\nmethod and read from the internal\nRecord (which in turn reads from its internal Row or Related objects).\nAlternatively, the end state might be \"DDD on top of ORM\" where Repositories map\nthe persistence model objects to domain Entities, Value Objects, and Aggregates.\n\n\nA persistence model alone should get you a long way, especially at the beginning\nof a project. Even so, the Row, Record, and RecordSet objects are disconnected\nfrom the database, which should make the refactoring process a lot cleaner than\nwith Active Record.\n\n\nOther rationalizations, essentially based around things I \ndo not\n want in an\nORM:\n\n\n\n\n\n\nNo annotations. I want the code to be in code, not in comments.\n\n\n\n\n\n\nNo migrations or other table-modification logic. Many ORMs read the PHP objects\nand then create or modify tables from them. I want the persistence system to be\na \nmodel\n of the schema, not a \ncreator\n of it. If I need a migration, I'll use\na tool specifically for migrations.\n\n\n\n\n\n\nNo lazy-loading. Lazy-loading is seductive but eventually is more trouble than\nit's worth; I don't want it to be available at all, so that it cannot accidently\nbe invoked.\n\n\n\n\n\n\nNo data-type abstractions. I used to think data-type abstraction was great,\nbut it turns out to be another thing that's just not worth the cost. I want the\nactual underlying database types to be exposed and available as much as\npossible.\n\n\n\n\n\n\nPossible deal-breakers for potential users:\n\n\n\n\n\n\nAtlas uses code generation, though only in a very limited way. I'm not a fan\nof code generation myself, but it turns out to be useful for building the SQL\ntable classes. Each table is described as a PHP class, one that just returns\nthings like the table name, the column names, etc. That's the only class that\nreally gets generated by Atlas; the others are just empty extensions of parent\nclasses.\n\n\n\n\n\n\nAtlas uses base Row, Record, and RecordSet classes, instead of plain-old PHP\nobjects. If this were a domain modeling system, a base class would be\nunacceptable. Because Atlas is a \npersistence\n modeling system, I think a base\nclass is less objectionable, but for some people that's going to be a real\nproblem.\n\n\n\n\n\n\nFinally, Atlas supports \ncomposite primary keys\n and \ncomposite foreign\nkeys.\n Performance in these cases is sure to be slower, but it is in fact\nsupported.", 
            "title": "Home"
        }, 
        {
            "location": "/#atlasorm", 
            "text": "No annotations. No migrations. No lazy loading. No data-type abstractions.   Atlas is a  data mapper \nimplementation for your  persistence model  ( not  your domain model).  As such, Atlas uses the term \"record\" to indicate that its objects are  not \ndomain entities. Note that an Atlas record is a  passive  record, not an  active\nrecord ; it is\ndisconnected from the database. Use Atlas records as a way to populate your\ndomain entities, or use them directly for simple data source interactions.  Atlas is stable for production use. Please send bug reports and pull requests!", 
            "title": "Atlas.Orm"
        }, 
        {
            "location": "/#rationale", 
            "text": "(Or, \"Why does Atlas exist?\")  I wanted an alternative to Active Record that would allow you to get started\nabout as easily as Active Record for your  persistence  model, and then refactor\nmore easily towards a richer  domain  model as needed.  Using a table data gateway for the underlying table Rows, then composing them\ninto Records and RecordSets via a data mapper, does the trick. As you begin to\nneed simple behaviors, you can add them to the Record and RecordSet persistence\nmodel objects. (Rows do not have behavior.) Your domain logic layer (e.g. a\nservice layer) can then use them as needed.  However, per  this article from Mehdi Khalili , the target end-state for\nyour modeling should eventually move toward \"Domain Model composed of\nPersistence Model\". That is, the domain Entity and Aggregate classes might use\ndata source Records and RecordSets internally, but will not expose them. They\ncan manipulate the persistence model objects internally as much as they wish.\nE.g., an Entity might have a  getAddress() method and read from the internal\nRecord (which in turn reads from its internal Row or Related objects).\nAlternatively, the end state might be \"DDD on top of ORM\" where Repositories map\nthe persistence model objects to domain Entities, Value Objects, and Aggregates.  A persistence model alone should get you a long way, especially at the beginning\nof a project. Even so, the Row, Record, and RecordSet objects are disconnected\nfrom the database, which should make the refactoring process a lot cleaner than\nwith Active Record.  Other rationalizations, essentially based around things I  do not  want in an\nORM:    No annotations. I want the code to be in code, not in comments.    No migrations or other table-modification logic. Many ORMs read the PHP objects\nand then create or modify tables from them. I want the persistence system to be\na  model  of the schema, not a  creator  of it. If I need a migration, I'll use\na tool specifically for migrations.    No lazy-loading. Lazy-loading is seductive but eventually is more trouble than\nit's worth; I don't want it to be available at all, so that it cannot accidently\nbe invoked.    No data-type abstractions. I used to think data-type abstraction was great,\nbut it turns out to be another thing that's just not worth the cost. I want the\nactual underlying database types to be exposed and available as much as\npossible.    Possible deal-breakers for potential users:    Atlas uses code generation, though only in a very limited way. I'm not a fan\nof code generation myself, but it turns out to be useful for building the SQL\ntable classes. Each table is described as a PHP class, one that just returns\nthings like the table name, the column names, etc. That's the only class that\nreally gets generated by Atlas; the others are just empty extensions of parent\nclasses.    Atlas uses base Row, Record, and RecordSet classes, instead of plain-old PHP\nobjects. If this were a domain modeling system, a base class would be\nunacceptable. Because Atlas is a  persistence  modeling system, I think a base\nclass is less objectionable, but for some people that's going to be a real\nproblem.    Finally, Atlas supports  composite primary keys  and  composite foreign\nkeys.  Performance in these cases is sure to be slower, but it is in fact\nsupported.", 
            "title": "Rationale"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nInstallation\n\n\nThis package is installable and autoloadable via \nComposer\n\nas \natlas/orm\n. Add the following lines\nto your \ncomposer.json\n file, then call \ncomposer update\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n{\n\n    \nrequire\n:\n \n{\n\n        \natlas/orm\n:\n \n~1.0\n\n    \n},\n\n    \nrequire-dev\n:\n \n{\n\n        \natlas/cli\n:\n \n~1.0\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n(The \natlas/cli\n package provides the \natlas-skeleton\n command-line tool to\nhelp create skeleton classes for the mapper.)\n\n\nCreating Data Source Classes\n\n\nYou can create your data source classes by hand, but it's going to be tedious to\ndo so. Instead, use the \natlas-skeleton\n command to read the table information\nfrom the database. You can read more about that in the\n\natlas/cli docs\n.\n\n\nInstantiating Atlas\n\n\nCreate an Atlas instance using the AtlasContainer.\n\n\nThe container accepts a \nPDO\n, \nExtendedPdo\n or \nConnectionLocator\n instance or you \ncan enter connection parameters and the container creates a connection for you.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nPDO\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nExtendedPdo\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nConnectionLocator\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\n\n    \nmysql:host=localhost;dbname=testdb\n,\n\n    \nusername\n,\n\n    \npassword\n\n\n);\n\n\n\n\n\n\n\nNext, set the available mapper classes into the container.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$atlasContainer\n-\nsetMappers\n([\n\n    \nAuthorMapper\n::\nCLASS\n,\n\n    \nReplyMapper\n::\nCLASS\n,\n\n    \nSummaryMapper\n::\nCLASS\n,\n\n    \nTagMapper\n::\nCLASS\n,\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \nTaggingMapper\n::\nCLASS\n,\n\n\n]);\n\n\n\n\n\n\n\nFinally, get back the Atlas instance out of the container.\n\n\n1\n2\n?php\n\n\n$atlas\n \n=\n \n$atlasContainer\n-\ngetAtlas\n();", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "This package is installable and autoloadable via  Composer \nas  atlas/orm . Add the following lines\nto your  composer.json  file, then call  composer update .  1\n2\n3\n4\n5\n6\n7\n8 { \n     require :   { \n         atlas/orm :   ~1.0 \n     }, \n     require-dev :   { \n         atlas/cli :   ~1.0 \n     }  }    (The  atlas/cli  package provides the  atlas-skeleton  command-line tool to\nhelp create skeleton classes for the mapper.)", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#creating-data-source-classes", 
            "text": "You can create your data source classes by hand, but it's going to be tedious to\ndo so. Instead, use the  atlas-skeleton  command to read the table information\nfrom the database. You can read more about that in the atlas/cli docs .", 
            "title": "Creating Data Source Classes"
        }, 
        {
            "location": "/getting-started/#instantiating-atlas", 
            "text": "Create an Atlas instance using the AtlasContainer.  The container accepts a  PDO ,  ExtendedPdo  or  ConnectionLocator  instance or you \ncan enter connection parameters and the container creates a connection for you.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  $atlasContainer   =   new   AtlasContainer ( new   PDO ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( new   ExtendedPdo ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( new   ConnectionLocator ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( \n     mysql:host=localhost;dbname=testdb , \n     username , \n     password  );    Next, set the available mapper classes into the container.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $atlasContainer - setMappers ([ \n     AuthorMapper :: CLASS , \n     ReplyMapper :: CLASS , \n     SummaryMapper :: CLASS , \n     TagMapper :: CLASS , \n     ThreadMapper :: CLASS , \n     TaggingMapper :: CLASS ,  ]);    Finally, get back the Atlas instance out of the container.  1\n2 ?php  $atlas   =   $atlasContainer - getAtlas ();", 
            "title": "Instantiating Atlas"
        }, 
        {
            "location": "/relationships/", 
            "text": "Mapper Relationships\n\n\nYou can add relationships to a mapper inside its \nsetRelated()\n method, calling\none of the four available relationship-definition methods:\n\n\n\n\noneToOne($field, $mapperClass)\n (aka \"has one\")\n\n\nmanyToOne($field, $mapperClass)\n (aka \"belongs to\")\n\n\noneToMany($field, $mapperClass)\n (aka \"has many\")\n\n\nmanyToMany($field, $mapperClass, $throughField)\n (aka \"has many through\")\n\n\n\n\nThe \n$field\n will become a field name on the returned Record object. That field\nwill be populated from the specified \n$mapperClass\n in Atlas. (In the case of\n\nmanyToMany()\n, the association mappings will come from the specified\n\n$throughField\n.)\n\n\nHere is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n?php\n\n\nnamespace\n \nApp\\DataSource\\Thread\n;\n\n\n\nuse\n \nApp\\DataSource\\Author\\AuthorMapper\n;\n\n\nuse\n \nApp\\DataSource\\Summary\\SummaryMapper\n;\n\n\nuse\n \nApp\\DataSource\\Reply\\ReplyMapper\n;\n\n\nuse\n \nApp\\DataSource\\Tagging\\TaggingMapper\n;\n\n\nuse\n \nApp\\DataSource\\Tag\\TagMapper\n;\n\n\nuse\n \nAtlas\\Orm\\Mapper\\AbstractMapper\n;\n\n\n\nclass\n \nThreadMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\nmanyToOne\n(\nauthor\n,\n \nAuthorMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToOne\n(\nsummary\n,\n \nSummaryMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToMany\n(\nreplies\n,\n \nReplyMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToMany\n(\ntaggings\n,\n \nTaggingMapper\n::\nCLASS\n);\n\n        \n$this\n-\nmanyToMany\n(\ntags\n,\n \nTagMapper\n::\nCLASS\n,\n \ntaggings\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nRelationship Key Columns\n\n\nBy default, in all relationships except many-to-one, the relationship will take\nthe primary key column(s) in the native table, and map to those same column\nnames in the foreign table.\n\n\nIn the case of many-to-one, it is the reverse; that is, the relationship will\ntake the primary key column(s) in the foreign table, and map to those same\ncolumn names in the native table.\n\n\nIf you want to use different columns, call the \non()\n method on the\nrelationship. For example, if the threads table uses \nauthor_id\n, but the\nauthors table uses just \nid\n, you can do this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nThreadMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\nmanyToOne\n(\nauthor\n,\n \nAuthorMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (threads) column =\n foreign (authors) column\n\n                \nauthor_id\n \n=\n \nid\n,\n\n            \n]);\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nAnd on the \noneToMany\n side of the relationship, you use the native author table\n\nid\n column with the foreign threads table \nauthor_id\n column.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nAuthorMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nposts\n,\n \nPostsMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (author) column =\n foreign (threads) column\n\n                \nid\n \n=\n \nauthor_id\n,\n\n            \n]);\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nComposite Relationship Keys\n\n\nLikewise, if a table uses a composite key, you can re-map the relationship on\nmultiple columns. If table \nfoo\n has composite primary key columns of \nacol\n and\n\nbcol\n, and it maps to table \nbar\n on \nfoo_acol\n and \nfoo_bcol\n, you would do\nthis:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nFooMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nbars\n,\n \nBarMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (foo) column =\n foreign (bar) column\n\n                \nacol\n \n=\n \nfoo_acol\n,\n\n                \nbcol\n \n=\n \nfoo_bcol\n,\n\n            \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nCase-Sensitivity\n\n\n\n\nN.b.: This applies only to \nstring-based\n relationship keys. If you are\nusing numeric relationship keys, this section does not apply.\n\n\n\n\nAtlas will match records related by string keys in a case-senstive manner. If\nyour collations on the related string key columns are \nnot\n case sensitive,\nAtlas might not match up related records properly in memory after fetching them\nfrom the database. This is because 'foo' and 'FOO' might be equivalent in the\ndatabase collation, but they are \nnot\n equivalent in PHP.\n\n\nIn that kind of situation, you will want to tell the relationship to ignore the\ncase of related string key columns when matching related records. You can do so\nwith the \nignoreCase()\n method on the relationship definition.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\nclass\n \nFooMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nbars\n,\n \nBarMapper\n::\nCLASS\n)\n\n            \n-\nignoreCase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nWith that in place, a native value of 'foo' match to a foreign value of 'FOO'\nwhen Atlas is stitching together related records.\n\n\nSimple WHERE Conditions\n\n\nYou may find it useful to define simple WHERE conditions on the foreign side of\nthe relationship. For example, you can handle one side of a so-called\npolymorphic relationship by selecting only related records of a particular type.\n\n\nIn the following example, a \ncomments\n table has a \ncommentable_id\n column as\nthe foreign key value, but is restricted to \"issue\" values on a discriminator\ncolumn named \ncommentable\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nclass IssueMapper extends AbstractMapper\n\n\n{\n\n\n    protected function setRelated()\n\n\n    {\n\n\n        $this-\noneToMany(\ncomments\n, CommentMapper::CLASS)\n\n\n            -\non([\n\n\n                \nissue_id\n =\n \ncommentable_id\n\n\n            ])\n\n\n            -\nwhere(\ncommentable = ?\n, \nissue\n);\n\n\n    }\n\n\n}\n\n\n\n\n\n\n\n(These conditions will be honored by \nMapperSelect::*joinWith()\n as well.)", 
            "title": "Mapper Relationships"
        }, 
        {
            "location": "/relationships/#mapper-relationships", 
            "text": "You can add relationships to a mapper inside its  setRelated()  method, calling\none of the four available relationship-definition methods:   oneToOne($field, $mapperClass)  (aka \"has one\")  manyToOne($field, $mapperClass)  (aka \"belongs to\")  oneToMany($field, $mapperClass)  (aka \"has many\")  manyToMany($field, $mapperClass, $throughField)  (aka \"has many through\")   The  $field  will become a field name on the returned Record object. That field\nwill be populated from the specified  $mapperClass  in Atlas. (In the case of manyToMany() , the association mappings will come from the specified $throughField .)  Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ?php  namespace   App\\DataSource\\Thread ;  use   App\\DataSource\\Author\\AuthorMapper ;  use   App\\DataSource\\Summary\\SummaryMapper ;  use   App\\DataSource\\Reply\\ReplyMapper ;  use   App\\DataSource\\Tagging\\TaggingMapper ;  use   App\\DataSource\\Tag\\TagMapper ;  use   Atlas\\Orm\\Mapper\\AbstractMapper ;  class   ThreadMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - manyToOne ( author ,   AuthorMapper :: CLASS ); \n         $this - oneToOne ( summary ,   SummaryMapper :: CLASS ); \n         $this - oneToMany ( replies ,   ReplyMapper :: CLASS ); \n         $this - oneToMany ( taggings ,   TaggingMapper :: CLASS ); \n         $this - manyToMany ( tags ,   TagMapper :: CLASS ,   taggings ); \n     }  }", 
            "title": "Mapper Relationships"
        }, 
        {
            "location": "/relationships/#relationship-key-columns", 
            "text": "By default, in all relationships except many-to-one, the relationship will take\nthe primary key column(s) in the native table, and map to those same column\nnames in the foreign table.  In the case of many-to-one, it is the reverse; that is, the relationship will\ntake the primary key column(s) in the foreign table, and map to those same\ncolumn names in the native table.  If you want to use different columns, call the  on()  method on the\nrelationship. For example, if the threads table uses  author_id , but the\nauthors table uses just  id , you can do this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   ThreadMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - manyToOne ( author ,   AuthorMapper :: CLASS ) \n             - on ([ \n                 // native (threads) column =  foreign (authors) column \n                 author_id   =   id , \n             ]); \n         // ... \n     }  }    And on the  oneToMany  side of the relationship, you use the native author table id  column with the foreign threads table  author_id  column.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   AuthorMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( posts ,   PostsMapper :: CLASS ) \n             - on ([ \n                 // native (author) column =  foreign (threads) column \n                 id   =   author_id , \n             ]); \n         // ... \n     }  }", 
            "title": "Relationship Key Columns"
        }, 
        {
            "location": "/relationships/#composite-relationship-keys", 
            "text": "Likewise, if a table uses a composite key, you can re-map the relationship on\nmultiple columns. If table  foo  has composite primary key columns of  acol  and bcol , and it maps to table  bar  on  foo_acol  and  foo_bcol , you would do\nthis:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   FooMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( bars ,   BarMapper :: CLASS ) \n             - on ([ \n                 // native (foo) column =  foreign (bar) column \n                 acol   =   foo_acol , \n                 bcol   =   foo_bcol , \n             ]); \n     }  }", 
            "title": "Composite Relationship Keys"
        }, 
        {
            "location": "/relationships/#case-sensitivity", 
            "text": "N.b.: This applies only to  string-based  relationship keys. If you are\nusing numeric relationship keys, this section does not apply.   Atlas will match records related by string keys in a case-senstive manner. If\nyour collations on the related string key columns are  not  case sensitive,\nAtlas might not match up related records properly in memory after fetching them\nfrom the database. This is because 'foo' and 'FOO' might be equivalent in the\ndatabase collation, but they are  not  equivalent in PHP.  In that kind of situation, you will want to tell the relationship to ignore the\ncase of related string key columns when matching related records. You can do so\nwith the  ignoreCase()  method on the relationship definition.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  class   FooMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( bars ,   BarMapper :: CLASS ) \n             - ignoreCase (); \n     }  }    With that in place, a native value of 'foo' match to a foreign value of 'FOO'\nwhen Atlas is stitching together related records.", 
            "title": "Case-Sensitivity"
        }, 
        {
            "location": "/relationships/#simple-where-conditions", 
            "text": "You may find it useful to define simple WHERE conditions on the foreign side of\nthe relationship. For example, you can handle one side of a so-called\npolymorphic relationship by selecting only related records of a particular type.  In the following example, a  comments  table has a  commentable_id  column as\nthe foreign key value, but is restricted to \"issue\" values on a discriminator\ncolumn named  commentable .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 class IssueMapper extends AbstractMapper  {      protected function setRelated()      {          $this- oneToMany( comments , CommentMapper::CLASS)              - on([                   issue_id  =   commentable_id              ])              - where( commentable = ? ,  issue );      }  }    (These conditions will be honored by  MapperSelect::*joinWith()  as well.)", 
            "title": "Simple WHERE Conditions"
        }, 
        {
            "location": "/reading/", 
            "text": "Reading Records and RecordSets\n\n\nUse Atlas to retrieve a single Record, or many Records in a RecordSet, from the database.\n\n\nReading a Record\n\n\nUse the \nfetchRecord()\n method to retrieve a single Record. It can be called\neither by primary key, or with a \nselect()\n query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n// fetch by primary key thread_id = 1\n\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nclass\n,\n\n    \n1\n\n\n);\n\n\n\n$threadRecord\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n1\n)\n\n    \n-\nfetchRecord\n();\n\n\n\n\n\n\n\nUse the \nfetchRecordBy()\n method to find a record by one or more equality pairs.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\n// If more than one is found, the first match will be returned\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecordBy\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \nauthor_id\n=\n3\n,\n\n        \npublished\n=\n1\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nThe example above is equivalent to...\n\n\n1\n2\n3\n4\n5\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\nauthor_id=\n,\n \n3\n)\n\n    \n-\nwhere\n(\npublished=?\n,\n \n1\n)\n\n    \n-\nfetchRecord\n();\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nselect()\n variation gives you access to all the underlying\nSQL query methods. See \nAura\\SqlQuery\n \nfor more information.\n\n\n\n\nIf \nfetchRecord()\n or  \nfetchRecordBy()\n does not find a match, it will return \nfalse\n.\n\n\nReading A RecordSet\n\n\nThe \nfetchRecordSet()\n method works the same as \nfetchRecord()\n, but for\nmultiple Records.  It can be called either with primary keys, or with a\n\nselect()\n query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n// fetch thread_id 1, 2, and 3\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n);\n\n\n\n// This is identical to the example above, but uses the `select()` variation.\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\nthread_id IN (?)\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\nTo return all rows, use the \nselect()\n variation as shown below.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\n// Use the `select()` variation to fetch all records, optionally ordering the\n\n\n// returned results\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\norderBy\n([\ndate_added DESC\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\nUse the \nfetchRecordSetBy()\n method to find a RecordSet by one or more equality pairs.\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n$threadRecords\n \n=\n \n$atlas\n-\nfetchRecordSetBy\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \nauthor_id\n=\n3\n,\n\n        \npublished\n=\n1\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nThe example above is equivalent to...\n\n\n1\n2\n3\n4\n5\n?php\n\n\n$threadRecords\n \n=\n \n$atlas\n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\nauthor_id=\n,\n \n3\n)\n\n    \n-\nwhere\n(\npublished=?\n,\n \n1\n)\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe \nselect()\n variation gives you access to all the underlying\nSQL query methods. See \nAura\\SqlQuery\n\nfor more information.\n\n\n\n\nIf \nfetchRecordSet()\n or \nfetchRecordSetBy()\n do not find any matches, they will\nreturn an empty array. This is important as you cannot call RecordSet methods\n(see later in the documentation) such as \nappendNew()\n or \ngetArrayCopy()\n on\nan empty array. In these situations, you must test for the empty array, and then\ninstantiate a new RecordSet, if necessary.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n?php\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n);\n\n\nif\n \n(\n!\n \n$threadRecordSet\n)\n \n{\n\n    \n$threadRecordSet\n \n=\n \n$atlas\n-\nnewRecordSet\n(\nThreadMapper\n::\nCLASS\n);\n\n\n}\n\n\n\n$threadMapper\n-\nappendNew\n(\n...\n);\n\n\n\n\n\n\n\nReading Relateds\n\n\nAny relationships that are set in the Mapper will appear as \nNULL\n in the Record\nobject.  Related data will only be populated if it explicitly requested as part\nof the fetch or select.\n\n\nOn a \nfetch*()\n, load relateds using a third argument: an array specifying\nwhich related fields to retrieve.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n]\n\n\n);\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\n\n\nNote\n\n\nWhen fetching a \nmanyToMany\n relationship, you must explicitly specify\nboth the association (join) table AND the \nmanyToMany\n table. Additionally, you\nmust specify these relationships in the correct order.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \ntaggings\n,\n \n// specify the join table first\n\n        \ntags\n \n// then the manyToMany table\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nOn a \nselect()\n, load relateds using the \nwith()\n method:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n$threadRecord = $atlas\n\n\n    -\nselect(ThreadMapper::class)\n\n\n    -\nwhere(\nthread_id = ?\n, \n1\n)\n\n\n    -\nwith([\n\n\n        \nauthor\n,\n\n\n        \nsummary\n,\n\n\n        \nreplies\n,\n\n\n    ])\n\n\n    -\nfetchRecord();\n\n\n\n$threadRecordSet = $atlas\n\n\n    -\nselect(ThreadMapper::CLASS)\n\n\n    -\nwhere(\nthread_id IN (?)\n, [1, 2, 3])\n\n\n    -\nwith([\n\n\n        \nauthor\n,\n\n\n        \nsummary\n,\n\n\n        \nreplies\n,\n\n\n    ])\n\n\n    -\nfetchRecordSet();\n\n\n\n\n\n\n\nRelationships can be nested as deeply as needed. For example, to fetch the\nauthor of each reply on each thread:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n$threadRecord\n \n=\n \n$this\n-\natlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n$threadId\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \n[\n\n            \nauthor\n\n        \n]\n\n    \n])\n\n    \n-\nfetchRecord\n();\n\n\n\n\n\n\n\nAlternatively, you can pass a closure to exercise fine control over the query\nthat fetches the relateds:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n?php\n\n\n// fetch thread_id 1; with only the last 10 related replies in descending order;\n\n\n// including each reply author\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \nfunction\n \n(\n$selectReplies\n)\n \n{\n\n            \n$selectReplies\n\n                \n-\nlimit\n(\n10\n)\n\n                \n-\norderBy\n([\nreply_id DESC\n])\n\n                \n-\nwith\n([\n\n                    \nauthor\n\n                \n]);\n\n        \n},\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nReading/Accessing Data\n\n\nColumn names and relationship names are mapped to properties of a Record.\nRelationships must be explicitly requested or their value will be NULL.\n\n\nAssume a table with the following columns:\n\n\n\n---------------------------------------------------------------------------\nthread_id    | title    | body    | author_id | date_added   | date_created\n-------------+----------+---------+-----------+--------------+-------------\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n\n\n);\n\n\n\necho\n \n$threadRecord\n-\ntitle\n;\n\n\n\n// If there were a related named `author`, its value would be `NULL` as it was\n\n\n// not requests in the fetch.\n\n\nvar_dump\n(\n$threadRecord\n-\nauthor\n);\n \n// NULL\n\n\n\n\n\n\n\nBy requesting the author related, you can then access its data via properties.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \nauthor\n\n    \n]\n\n\n);\n\n\n\n// `first_name` maps to a column name in the authors table.\n\n\necho\n \n$threadRecord\n-\nauthor\n-\nfirst_name\n;\n\n\n\n\n\n\n\nRelationships can be nested, but as long as a related exists, you can access its\ndata.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n?php\n\n\n$threadRecord\n \n=\n \n$this\n-\natlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n$threadId\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \n[\n\n            \nauthor\n\n        \n]\n\n    \n])\n\n    \n-\nfetchRecord\n();\n\n\n\nforeach\n \n(\n$threadRecord\n-\nreplies\n \nas\n \n$reply\n)\n \n{\n\n    \necho\n \n$reply\n-\nauthor\n-\nfirst_name\n;\n\n\n}\n\n\n\n\n\n\n\nReturning Data in Other Formats\n\n\nYou can return a Record or a RecordSet as an \narray\n rather than a Record or\nRecordSet object using the \ngetArrayCopy()\n method.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper::CLASS\n,\n \n1\n);\n\n\n$threadArray\n \n=\n \n$threadRecord\n-\ngetArrayCopy\n();\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\norderBy\n([\ndate_added DESC\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n$threadsArray\n \n=\n \n$threadRecordSet\n-\ngetArrayCopy\n();\n\n\n\n\n\n\n\nJSON-encoding Records and RecordSets is trival.\n\n\n1\n2\n3\n?php\n\n\n$threadJson\n \n=\n \njson_encode\n(\n$threadRecord\n);\n\n\n$threadsJson\n \n=\n \njson_encode\n(\n$threadRecordSet\n);\n\n\n\n\n\n\n\nReading Record Counts\n\n\nIf you use a \nselect()\n to fetch a RecordSet with a \nlimit()\n or \npage()\n, you\ncan re-use the select to get a count of how many Records would have been\nreturned. This can be useful for paging displays.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\n$select\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n\n    \n])\n\n    \n-\nlimit\n(\n10\n)\n\n    \n-\noffset\n(\n20\n);\n\n\n\n$threadRecordSet\n \n=\n \n$select\n-\nfetchRecordSet\n();\n\n\n$countOfAllThreads\n \n=\n \n$select\n-\nfetchCount\n();", 
            "title": "Reading Records and RecordSets"
        }, 
        {
            "location": "/reading/#reading-records-and-recordsets", 
            "text": "Use Atlas to retrieve a single Record, or many Records in a RecordSet, from the database.", 
            "title": "Reading Records and RecordSets"
        }, 
        {
            "location": "/reading/#reading-a-record", 
            "text": "Use the  fetchRecord()  method to retrieve a single Record. It can be called\neither by primary key, or with a  select()  query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  // fetch by primary key thread_id = 1  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: class , \n     1  );  $threadRecord   =   $atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   1 ) \n     - fetchRecord ();    Use the  fetchRecordBy()  method to find a record by one or more equality pairs.  1\n2\n3\n4\n5\n6\n7\n8 ?php  // If more than one is found, the first match will be returned  $threadRecord   =   $atlas - fetchRecordBy ( ThreadMapper :: CLASS , \n     [ \n         author_id = 3 , \n         published = 1 \n     ]  );    The example above is equivalent to...  1\n2\n3\n4\n5 ?php  $threadRecord   =   $atlas - select ( ThreadMapper :: CLASS ) \n     - where ( author_id= ,   3 ) \n     - where ( published=? ,   1 ) \n     - fetchRecord ();     Note  The  select()  variation gives you access to all the underlying\nSQL query methods. See  Aura\\SqlQuery  \nfor more information.   If  fetchRecord()  or   fetchRecordBy()  does not find a match, it will return  false .", 
            "title": "Reading a Record"
        }, 
        {
            "location": "/reading/#reading-a-recordset", 
            "text": "The  fetchRecordSet()  method works the same as  fetchRecord() , but for\nmultiple Records.  It can be called either with primary keys, or with a select()  query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  // fetch thread_id 1, 2, and 3  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ]  );  // This is identical to the example above, but uses the `select()` variation.  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - where ( thread_id IN (?) ,   [ 1 ,   2 ,   3 ]) \n     - fetchRecordSet ();    To return all rows, use the  select()  variation as shown below.  1\n2\n3\n4\n5\n6\n7\n8 ?php  // Use the `select()` variation to fetch all records, optionally ordering the  // returned results  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - orderBy ([ date_added DESC ]) \n     - fetchRecordSet ();    Use the  fetchRecordSetBy()  method to find a RecordSet by one or more equality pairs.  1\n2\n3\n4\n5\n6\n7 ?php  $threadRecords   =   $atlas - fetchRecordSetBy ( ThreadMapper :: CLASS , \n     [ \n         author_id = 3 , \n         published = 1 \n     ]  );    The example above is equivalent to...  1\n2\n3\n4\n5 ?php  $threadRecords   =   $atlas - select ( ThreadMapper :: CLASS ) \n     - where ( author_id= ,   3 ) \n     - where ( published=? ,   1 ) \n     - fetchRecordSet ();     Note  The  select()  variation gives you access to all the underlying\nSQL query methods. See  Aura\\SqlQuery \nfor more information.   If  fetchRecordSet()  or  fetchRecordSetBy()  do not find any matches, they will\nreturn an empty array. This is important as you cannot call RecordSet methods\n(see later in the documentation) such as  appendNew()  or  getArrayCopy()  on\nan empty array. In these situations, you must test for the empty array, and then\ninstantiate a new RecordSet, if necessary.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ?php  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ]  );  if   ( !   $threadRecordSet )   { \n     $threadRecordSet   =   $atlas - newRecordSet ( ThreadMapper :: CLASS );  }  $threadMapper - appendNew ( ... );", 
            "title": "Reading A RecordSet"
        }, 
        {
            "location": "/reading/#reading-relateds", 
            "text": "Any relationships that are set in the Mapper will appear as  NULL  in the Record\nobject.  Related data will only be populated if it explicitly requested as part\nof the fetch or select.  On a  fetch*() , load relateds using a third argument: an array specifying\nwhich related fields to retrieve.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         author , \n         summary , \n         replies , \n     ]  );  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ], \n     [ \n         author , \n         summary , \n         replies , \n     ]  );     Note  When fetching a  manyToMany  relationship, you must explicitly specify\nboth the association (join) table AND the  manyToMany  table. Additionally, you\nmust specify these relationships in the correct order.   1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         taggings ,   // specify the join table first \n         tags   // then the manyToMany table \n     ]  );    On a  select() , load relateds using the  with()  method:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 $threadRecord = $atlas      - select(ThreadMapper::class)      - where( thread_id = ? ,  1 )      - with([           author ,           summary ,           replies ,      ])      - fetchRecord();  $threadRecordSet = $atlas      - select(ThreadMapper::CLASS)      - where( thread_id IN (?) , [1, 2, 3])      - with([           author ,           summary ,           replies ,      ])      - fetchRecordSet();    Relationships can be nested as deeply as needed. For example, to fetch the\nauthor of each reply on each thread:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  $threadRecord   =   $this - atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   $threadId ) \n     - with ([ \n         author , \n         summary , \n         replies   =   [ \n             author \n         ] \n     ]) \n     - fetchRecord ();    Alternatively, you can pass a closure to exercise fine control over the query\nthat fetches the relateds:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 ?php  // fetch thread_id 1; with only the last 10 related replies in descending order;  // including each reply author  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         author , \n         summary , \n         replies   =   function   ( $selectReplies )   { \n             $selectReplies \n                 - limit ( 10 ) \n                 - orderBy ([ reply_id DESC ]) \n                 - with ([ \n                     author \n                 ]); \n         }, \n     ]  );", 
            "title": "Reading Relateds"
        }, 
        {
            "location": "/reading/#readingaccessing-data", 
            "text": "Column names and relationship names are mapped to properties of a Record.\nRelationships must be explicitly requested or their value will be NULL.  Assume a table with the following columns:  \n---------------------------------------------------------------------------\nthread_id    | title    | body    | author_id | date_added   | date_created\n-------------+----------+---------+-----------+--------------+-------------   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1  );  echo   $threadRecord - title ;  // If there were a related named `author`, its value would be `NULL` as it was  // not requests in the fetch.  var_dump ( $threadRecord - author );   // NULL    By requesting the author related, you can then access its data via properties.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         author \n     ]  );  // `first_name` maps to a column name in the authors table.  echo   $threadRecord - author - first_name ;    Relationships can be nested, but as long as a related exists, you can access its\ndata.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 ?php  $threadRecord   =   $this - atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   $threadId ) \n     - with ([ \n         author , \n         summary , \n         replies   =   [ \n             author \n         ] \n     ]) \n     - fetchRecord ();  foreach   ( $threadRecord - replies   as   $reply )   { \n     echo   $reply - author - first_name ;  }", 
            "title": "Reading/Accessing Data"
        }, 
        {
            "location": "/reading/#returning-data-in-other-formats", 
            "text": "You can return a Record or a RecordSet as an  array  rather than a Record or\nRecordSet object using the  getArrayCopy()  method.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ?php  $threadRecord   =   $atlas - fetchRecord ( ThreadMapper::CLASS ,   1 );  $threadArray   =   $threadRecord - getArrayCopy ();  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - orderBy ([ date_added DESC ]) \n     - fetchRecordSet ();  $threadsArray   =   $threadRecordSet - getArrayCopy ();    JSON-encoding Records and RecordSets is trival.  1\n2\n3 ?php  $threadJson   =   json_encode ( $threadRecord );  $threadsJson   =   json_encode ( $threadRecordSet );", 
            "title": "Returning Data in Other Formats"
        }, 
        {
            "location": "/reading/#reading-record-counts", 
            "text": "If you use a  select()  to fetch a RecordSet with a  limit()  or  page() , you\ncan re-use the select to get a count of how many Records would have been\nreturned. This can be useful for paging displays.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  $select   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - with ([ \n         author , \n         summary , \n         replies \n     ]) \n     - limit ( 10 ) \n     - offset ( 20 );  $threadRecordSet   =   $select - fetchRecordSet ();  $countOfAllThreads   =   $select - fetchCount ();", 
            "title": "Reading Record Counts"
        }, 
        {
            "location": "/records/", 
            "text": "Working with Records\n\n\nCreating and Inserting a Record\n\n\nCreate a new Record using the \nnewRecord()\n method. You can assign data using\nproperties, or pass an array of initial data to populate into the Record.\n\n\n1\n2\n3\n4\n5\n6\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nYou can assign a value via a property, which maps to a column name.\n\n\n1\n2\n$date = new \\DateTime();\n\n\n$thread-\ndate_added = $date-\nformat(\nY-m-d H:i:s\n);\n\n\n\n\n\n\n\nYou can insert a single Record back to the database by using the Atlas \ninsert()\n\nmethod. This will use the appropriate Mapper for the Record to perform the\nwrite within a transaction, and capture any exceptions that occur along the way.\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nInserting a Record with an auto-incrementing primary key will automatically\nmodify the Record to set the last-inserted ID.\n\n\nInserting a Record will automatically set the foreign key fields on the native\nRecord, and on all the loaded relationships for that Record.\n\n\nIn the following example, assume a Thread Record has a \nmanyToOne\n relationship\nwith an Author Record using the \nauthor_id\n column. The relationship is named\n\nauthor\n. (See the section on relationships for more information.)\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\n$author\n \n=\n \n$atlas\n-\nfetchRecord\n(\nAuthorMapper\n::\nCLASS\n,\n \n4\n);\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n        \nauthor\n=\n$author\n\n    \n]\n\n\n);\n\n\n// If the insert is successful, the `author_id` column will automatically be\n\n\n// set to the Author Record\ns primary key value. In this case, 4.\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\n\necho\n \n$thread\n-\nauthor_id\n;\n \n// 4\n\n\n\n\n\n\n\n\n\nNote\n\n\nIf the Author Record is new, Atlas will NOT automatically insert the\nnew Author and set the foreign key on the new Author Record via the \ninsert()\n\nmethod. This can, however, be achieved using the \npersist()\n method. This is\ndiscussed later in this chapter.\n\n\n\n\nThe following will fail.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\n$author\n \n=\n \n$atlas\n-\nnewRecord\n(\nAuthorMapper\n::\nCLASS\n,\n\n    \n[\n\n        \nfirst_name\n=\nSterling\n,\n\n        \nlast_name\n=\nArcher\n\n    \n]\n\n\n);\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n        \nauthor\n=\n$author\n\n    \n]\n\n\n);\n\n\n// Insert will not create the related Author Record. Use persist() instead.\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\n\n\n\n\n\nUpdating an Existing Record\n\n\nUpdating an existing record works the same as \ninsert()\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n?php\n\n\n// fetch an existing record by primary key\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n\n// Modify the title\n\n\n$thread\n-\ntitle\n \n=\n \nThis title is better than the last one\n;\n\n\n\n// Save the record back to the database.\n\n\n$success\n \n=\n \n$atlas\n-\nupdate\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nAs with \ninsert()\n, foreign keys are also updated, but only for existing related\nrecords.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n$author\n \n=\n \n$atlas\n-\nfetchRecord\n(\nAuthorMapper\n::\nCLASS\n,\n \n4\n);\n\n\n\n// Modify the author\n\n\n$thread\n-\nauthor\n \n=\n \n$author\n;\n\n\n\n// Save the record back to the database.\n\n\n$success\n \n=\n \n$atlas\n-\nupdate\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nDeleting a Record\n\n\nDeleting a record works the same as inserting or updating.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n\n$success\n \n=\n \n$atlas\n-\ndelete\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nRemoved record from the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not remove the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nPersisting a Record\n\n\nIf you like, you can persist a Record and all of its loaded relationships (and\nall of \ntheir\n loaded relationships, etc.) back to the database using the Atlas\n\npersist()\n method. This is good for straightforward relationship structures\nwhere the order of write operations does not need to be closely managed.\n\n\nThe \npersist()\n method will:\n\n\n\n\npersist many-to-one and many-to-many relateds loaded on the native Record;\n\n\npersist the native Record by ...\n\n\ninserting the Row for the Record if it is new; or,\n\n\nupdating the Row for the Record if it has been modified; or,\n\n\ndeleting the Row for the Record if the Record has been marked for deletion\n  using the Record::markForDeletion() method;\n\n\n\n\n\n\npersist one-to-one and one-to-many relateds loaded on the native Record.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n$success\n \n=\n \n$atlas\n-\npersist\n(\n$record\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record and all of its relateds back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nAs with insert and update, this will automatically set the foreign key fields on\nthe native Record, and on all the loaded relationships for that Record.\n\n\nIf a related field is not loaded, it cannot be persisted automatically.\n\n\nNote that whether or not the Row for the Record is inserted/updated/deleted, the\n\npersist()\n method will still recursively traverse all the related fields and\npersist them as well.\n\n\nThe \ndelete()\n method \nwill not\n attempt to cascade deletion or nullification\nacross relateds at the ORM level. Your database may have cascading set up at the\ndatabase level; Atlas has no control over this.\n\n\nMarking Records for Deletion\n\n\nYou may also mark records for deletion and they will be removed from the database\nafter a transaction is completed via \npersist()\n.\n\n\n1\n2\n3\n4\n5\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n// Mark the record for deletion\n\n\n$thread\n-\nmarkForDeletion\n();\n\n\n$atlas\n-\npersist\n(\n$thread\n);\n\n\n\n\n\n\n\nYou can also mark several related Records for deletion and when the native\nRecord is persisted, they will be deleted from the database.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n?php\n\n\n// Assume a oneToMany relationship between a thread and its comments\n\n\n// Select the thread and related comments\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n,\n\n    \n[\n\n        \ncomments\n\n    \n]\n\n\n);\n\n\n\n// Mark each related comment for deletion\n\n\nforeach\n \n(\n$thread\n-\ncomments\n \nas\n \n$comment\n)\n \n{\n\n    \n$comment\n-\nmarkForDeletion\n();\n\n\n}\n\n\n\n// Persist the thread and the comments are also deleted\n\n\n$atlas\n-\npersist\n(\n$thread\n);", 
            "title": "Working with Records"
        }, 
        {
            "location": "/records/#working-with-records", 
            "text": "", 
            "title": "Working with Records"
        }, 
        {
            "location": "/records/#creating-and-inserting-a-record", 
            "text": "Create a new Record using the  newRecord()  method. You can assign data using\nproperties, or pass an array of initial data to populate into the Record.  1\n2\n3\n4\n5\n6 ?php  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n     ]  );    You can assign a value via a property, which maps to a column name.  1\n2 $date = new \\DateTime();  $thread- date_added = $date- format( Y-m-d H:i:s );    You can insert a single Record back to the database by using the Atlas  insert() \nmethod. This will use the appropriate Mapper for the Record to perform the\nwrite within a transaction, and capture any exceptions that occur along the way.  1\n2\n3\n4\n5\n6\n7 ?php  $success   =   $atlas - insert ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    Inserting a Record with an auto-incrementing primary key will automatically\nmodify the Record to set the last-inserted ID.  Inserting a Record will automatically set the foreign key fields on the native\nRecord, and on all the loaded relationships for that Record.  In the following example, assume a Thread Record has a  manyToOne  relationship\nwith an Author Record using the  author_id  column. The relationship is named author . (See the section on relationships for more information.)   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  $author   =   $atlas - fetchRecord ( AuthorMapper :: CLASS ,   4 );  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n         author = $author \n     ]  );  // If the insert is successful, the `author_id` column will automatically be  // set to the Author Record s primary key value. In this case, 4.  $success   =   $atlas - insert ( $thread );  echo   $thread - author_id ;   // 4     Note  If the Author Record is new, Atlas will NOT automatically insert the\nnew Author and set the foreign key on the new Author Record via the  insert() \nmethod. This can, however, be achieved using the  persist()  method. This is\ndiscussed later in this chapter.   The following will fail.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  $author   =   $atlas - newRecord ( AuthorMapper :: CLASS , \n     [ \n         first_name = Sterling , \n         last_name = Archer \n     ]  );  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n         author = $author \n     ]  );  // Insert will not create the related Author Record. Use persist() instead.  $success   =   $atlas - insert ( $thread );", 
            "title": "Creating and Inserting a Record"
        }, 
        {
            "location": "/records/#updating-an-existing-record", 
            "text": "Updating an existing record works the same as  insert() .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ?php  // fetch an existing record by primary key  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  // Modify the title  $thread - title   =   This title is better than the last one ;  // Save the record back to the database.  $success   =   $atlas - update ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    As with  insert() , foreign keys are also updated, but only for existing related\nrecords.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  $author   =   $atlas - fetchRecord ( AuthorMapper :: CLASS ,   4 );  // Modify the author  $thread - author   =   $author ;  // Save the record back to the database.  $success   =   $atlas - update ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }", 
            "title": "Updating an Existing Record"
        }, 
        {
            "location": "/records/#deleting-a-record", 
            "text": "Deleting a record works the same as inserting or updating.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  $success   =   $atlas - delete ( $thread );  if   ( $success )   { \n     echo   Removed record from the database. ;  }   else   { \n     echo   Did not remove the Record:    .   $atlas - getException ();  }", 
            "title": "Deleting a Record"
        }, 
        {
            "location": "/records/#persisting-a-record", 
            "text": "If you like, you can persist a Record and all of its loaded relationships (and\nall of  their  loaded relationships, etc.) back to the database using the Atlas persist()  method. This is good for straightforward relationship structures\nwhere the order of write operations does not need to be closely managed.  The  persist()  method will:   persist many-to-one and many-to-many relateds loaded on the native Record;  persist the native Record by ...  inserting the Row for the Record if it is new; or,  updating the Row for the Record if it has been modified; or,  deleting the Row for the Record if the Record has been marked for deletion\n  using the Record::markForDeletion() method;    persist one-to-one and one-to-many relateds loaded on the native Record.   1\n2\n3\n4\n5\n6\n7 ?php  $success   =   $atlas - persist ( $record );  if   ( $success )   { \n     echo   Wrote the Record and all of its relateds back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    As with insert and update, this will automatically set the foreign key fields on\nthe native Record, and on all the loaded relationships for that Record.  If a related field is not loaded, it cannot be persisted automatically.  Note that whether or not the Row for the Record is inserted/updated/deleted, the persist()  method will still recursively traverse all the related fields and\npersist them as well.  The  delete()  method  will not  attempt to cascade deletion or nullification\nacross relateds at the ORM level. Your database may have cascading set up at the\ndatabase level; Atlas has no control over this.", 
            "title": "Persisting a Record"
        }, 
        {
            "location": "/records/#marking-records-for-deletion", 
            "text": "You may also mark records for deletion and they will be removed from the database\nafter a transaction is completed via  persist() .  1\n2\n3\n4\n5 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  // Mark the record for deletion  $thread - markForDeletion ();  $atlas - persist ( $thread );    You can also mark several related Records for deletion and when the native\nRecord is persisted, they will be deleted from the database.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 ?php  // Assume a oneToMany relationship between a thread and its comments  // Select the thread and related comments  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 , \n     [ \n         comments \n     ]  );  // Mark each related comment for deletion  foreach   ( $thread - comments   as   $comment )   { \n     $comment - markForDeletion ();  }  // Persist the thread and the comments are also deleted  $atlas - persist ( $thread );", 
            "title": "Marking Records for Deletion"
        }, 
        {
            "location": "/record-sets/", 
            "text": "Working with RecordSets\n\n\nSearching within RecordSets\n\n\nYou can search for Records by their column values:\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n// returns one matching Record object from the RecordSet,\n\n\n// or false if there is no match\n\n\n$matchingRecord\n \n=\n \n$threadRecordSet\n-\ngetOneBy\n([\nsubject\n \n=\n \nSubject One\n]);\n\n\n\n// returns an array of matching Record objects from the RecordSet\n\n\n$matchingRecords\n \n=\n \n$threadRecordSet\n-\ngetAllBy\n([\nauthor_id\n \n=\n \n5\n]);\n\n\n\n\n\n\n\nRemoving Records from RecordSets\n\n\nYou can remove Records from a RecordSet by their column values. This does NOT\ndelete the Record from the database; only from the RecordSet.\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n// unsets and returns one matching Record from the Record Set,\n\n\n// or false if there is no match\n\n\n$removedRecord\n \n=\n \n$threadRecordSet\n-\nremoveOneBy\n([\nsubject\n \n=\n \nSubject One\n]);\n\n\n\n// unsets and returns an array of matching Record objects from the Record Set\n\n\n$removedRecords\n \n=\n \n$threadRecordSet\n-\nremoveAllBy\n([\nauthor_id\n \n=\n \n5\n]);\n\n\n\n\n\n\n\nNote that this only removes them from the RecordSet; it does not delete them\nfrom the database. If you need to delete a record from the database, see the\nsection on Marking Records for Deletion.\n\n\nAppending Records to a RecordSet\n\n\nYou can append a new Record to an existing RecordSet using \nappendNew()\n, optionally passing any\ndata you want to initially populate into the Record:\n\n\n1\n2\n3\n4\n?php\n\n\n$newThread\n \n=\n \n$threadRecordSet\n-\nappendNew\n([\n\n    \ntitle\n \n=\n \nNew Title\n,\n\n\n]);", 
            "title": "Working with RecordSets"
        }, 
        {
            "location": "/record-sets/#working-with-recordsets", 
            "text": "", 
            "title": "Working with RecordSets"
        }, 
        {
            "location": "/record-sets/#searching-within-recordsets", 
            "text": "You can search for Records by their column values:  1\n2\n3\n4\n5\n6\n7 ?php  // returns one matching Record object from the RecordSet,  // or false if there is no match  $matchingRecord   =   $threadRecordSet - getOneBy ([ subject   =   Subject One ]);  // returns an array of matching Record objects from the RecordSet  $matchingRecords   =   $threadRecordSet - getAllBy ([ author_id   =   5 ]);", 
            "title": "Searching within RecordSets"
        }, 
        {
            "location": "/record-sets/#removing-records-from-recordsets", 
            "text": "You can remove Records from a RecordSet by their column values. This does NOT\ndelete the Record from the database; only from the RecordSet.  1\n2\n3\n4\n5\n6\n7 ?php  // unsets and returns one matching Record from the Record Set,  // or false if there is no match  $removedRecord   =   $threadRecordSet - removeOneBy ([ subject   =   Subject One ]);  // unsets and returns an array of matching Record objects from the Record Set  $removedRecords   =   $threadRecordSet - removeAllBy ([ author_id   =   5 ]);    Note that this only removes them from the RecordSet; it does not delete them\nfrom the database. If you need to delete a record from the database, see the\nsection on Marking Records for Deletion.", 
            "title": "Removing Records from RecordSets"
        }, 
        {
            "location": "/record-sets/#appending-records-to-a-recordset", 
            "text": "You can append a new Record to an existing RecordSet using  appendNew() , optionally passing any\ndata you want to initially populate into the Record:  1\n2\n3\n4 ?php  $newThread   =   $threadRecordSet - appendNew ([ \n     title   =   New Title ,  ]);", 
            "title": "Appending Records to a RecordSet"
        }
    ]
}