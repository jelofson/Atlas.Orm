{
    "docs": [
        {
            "location": "/", 
            "text": "Atlas.Orm\n\n\n\n\nNo annotations. No migrations. No lazy loading. No data-type abstractions.\n\n\n\n\nAtlas is a \ndata mapper\n\nimplementation for your \npersistence model\n (\nnot\n your domain model).\n\n\nAs such, Atlas uses the term \"record\" to indicate that its objects are \nnot\n\ndomain entities. Note that an Atlas record is a \npassive\n record, not an \nactive\nrecord\n; it is\ndisconnected from the database. Use Atlas records as a way to populate your\ndomain entities, or use them directly for simple data source interactions.\n\n\nAtlas is stable for production use. Please send bug reports and pull requests!\n\n\nRationale\n\n\n(Or, \"Why does Atlas exist?\")\n\n\nI wanted an alternative to Active Record that would allow you to get started\nabout as easily as Active Record for your \npersistence\n model, and then refactor\nmore easily towards a richer \ndomain\n model as needed.\n\n\nUsing a table data gateway for the underlying table Rows, then composing them\ninto Records and RecordSets via a data mapper, does the trick. As you begin to\nneed simple behaviors, you can add them to the Record and RecordSet persistence\nmodel objects. (Rows do not have behavior.) Your domain logic layer (e.g. a\nservice layer) can then use them as needed.\n\n\nHowever, per \nthis article from Mehdi Khalili\n, the target end-state for\nyour modeling should eventually move toward \"Domain Model composed of\nPersistence Model\". That is, the domain Entity and Aggregate classes might use\ndata source Records and RecordSets internally, but will not expose them. They\ncan manipulate the persistence model objects internally as much as they wish.\nE.g., an Entity might have a \ngetAddress()\nmethod and read from the internal\nRecord (which in turn reads from its internal Row or Related objects).\nAlternatively, the end state might be \"DDD on top of ORM\" where Repositories map\nthe persistence model objects to domain Entities, Value Objects, and Aggregates.\n\n\nA persistence model alone should get you a long way, especially at the beginning\nof a project. Even so, the Row, Record, and RecordSet objects are disconnected\nfrom the database, which should make the refactoring process a lot cleaner than\nwith Active Record.\n\n\nOther rationalizations, essentially based around things I \ndo not\n want in an\nORM:\n\n\n\n\n\n\nNo annotations. I want the code to be in code, not in comments.\n\n\n\n\n\n\nNo migrations or other table-modification logic. Many ORMs read the PHP objects\nand then create or modify tables from them. I want the persistence system to be\na \nmodel\n of the schema, not a \ncreator\n of it. If I need a migration, I'll use\na tool specifically for migrations.\n\n\n\n\n\n\nNo lazy-loading. Lazy-loading is seductive but eventually is more trouble than\nit's worth; I don't want it to be available at all, so that it cannot accidently\nbe invoked.\n\n\n\n\n\n\nNo data-type abstractions. I used to think data-type abstraction was great,\nbut it turns out to be another thing that's just not worth the cost. I want the\nactual underlying database types to be exposed and available as much as\npossible.\n\n\n\n\n\n\nPossible deal-breakers for potential users:\n\n\n\n\n\n\nAtlas uses code generation, though only in a very limited way. I'm not a fan\nof code generation myself, but it turns out to be useful for building the SQL\ntable classes. Each table is described as a PHP class, one that just returns\nthings like the table name, the column names, etc. That's the only class that\nreally gets generated by Atlas; the others are just empty extensions of parent\nclasses.\n\n\n\n\n\n\nAtlas uses base Row, Record, and RecordSet classes, instead of plain-old PHP\nobjects. If this were a domain modeling system, a base class would be\nunacceptable. Because Atlas is a \npersistence\n modeling system, I think a base\nclass is less objectionable, but for some people that's going to be a real\nproblem.\n\n\n\n\n\n\nFinally, Atlas supports \ncomposite primary keys\n and \ncomposite foreign\nkeys.\n Performance in these cases is sure to be slower, but it is in fact\nsupported.", 
            "title": "Home"
        }, 
        {
            "location": "/#atlasorm", 
            "text": "No annotations. No migrations. No lazy loading. No data-type abstractions.   Atlas is a  data mapper \nimplementation for your  persistence model  ( not  your domain model).  As such, Atlas uses the term \"record\" to indicate that its objects are  not \ndomain entities. Note that an Atlas record is a  passive  record, not an  active\nrecord ; it is\ndisconnected from the database. Use Atlas records as a way to populate your\ndomain entities, or use them directly for simple data source interactions.  Atlas is stable for production use. Please send bug reports and pull requests!", 
            "title": "Atlas.Orm"
        }, 
        {
            "location": "/#rationale", 
            "text": "(Or, \"Why does Atlas exist?\")  I wanted an alternative to Active Record that would allow you to get started\nabout as easily as Active Record for your  persistence  model, and then refactor\nmore easily towards a richer  domain  model as needed.  Using a table data gateway for the underlying table Rows, then composing them\ninto Records and RecordSets via a data mapper, does the trick. As you begin to\nneed simple behaviors, you can add them to the Record and RecordSet persistence\nmodel objects. (Rows do not have behavior.) Your domain logic layer (e.g. a\nservice layer) can then use them as needed.  However, per  this article from Mehdi Khalili , the target end-state for\nyour modeling should eventually move toward \"Domain Model composed of\nPersistence Model\". That is, the domain Entity and Aggregate classes might use\ndata source Records and RecordSets internally, but will not expose them. They\ncan manipulate the persistence model objects internally as much as they wish.\nE.g., an Entity might have a  getAddress() method and read from the internal\nRecord (which in turn reads from its internal Row or Related objects).\nAlternatively, the end state might be \"DDD on top of ORM\" where Repositories map\nthe persistence model objects to domain Entities, Value Objects, and Aggregates.  A persistence model alone should get you a long way, especially at the beginning\nof a project. Even so, the Row, Record, and RecordSet objects are disconnected\nfrom the database, which should make the refactoring process a lot cleaner than\nwith Active Record.  Other rationalizations, essentially based around things I  do not  want in an\nORM:    No annotations. I want the code to be in code, not in comments.    No migrations or other table-modification logic. Many ORMs read the PHP objects\nand then create or modify tables from them. I want the persistence system to be\na  model  of the schema, not a  creator  of it. If I need a migration, I'll use\na tool specifically for migrations.    No lazy-loading. Lazy-loading is seductive but eventually is more trouble than\nit's worth; I don't want it to be available at all, so that it cannot accidently\nbe invoked.    No data-type abstractions. I used to think data-type abstraction was great,\nbut it turns out to be another thing that's just not worth the cost. I want the\nactual underlying database types to be exposed and available as much as\npossible.    Possible deal-breakers for potential users:    Atlas uses code generation, though only in a very limited way. I'm not a fan\nof code generation myself, but it turns out to be useful for building the SQL\ntable classes. Each table is described as a PHP class, one that just returns\nthings like the table name, the column names, etc. That's the only class that\nreally gets generated by Atlas; the others are just empty extensions of parent\nclasses.    Atlas uses base Row, Record, and RecordSet classes, instead of plain-old PHP\nobjects. If this were a domain modeling system, a base class would be\nunacceptable. Because Atlas is a  persistence  modeling system, I think a base\nclass is less objectionable, but for some people that's going to be a real\nproblem.    Finally, Atlas supports  composite primary keys  and  composite foreign\nkeys.  Performance in these cases is sure to be slower, but it is in fact\nsupported.", 
            "title": "Rationale"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nInstallation\n\n\nThis package is installable and autoloadable via \nComposer\n\nas \natlas/orm\n. Add the following lines\nto your \ncomposer.json\n file, then call \ncomposer update\n.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n{\n\n    \nrequire\n:\n \n{\n\n        \natlas/orm\n:\n \n~1.0\n\n    \n},\n\n    \nrequire-dev\n:\n \n{\n\n        \natlas/cli\n:\n \n~1.0\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n(The \natlas/cli\n package provides the \natlas-skeleton\n command-line tool to\nhelp create skeleton classes for the mapper.)\n\n\nCreating Data Source Classes\n\n\nYou can create your data source classes by hand, but it's going to be tedious to\ndo so. Instead, use the \natlas-skeleton\n command to read the table information\nfrom the database. You can read more about that in the\n\natlas/cli docs\n.\n\n\nInstantiating Atlas\n\n\nCreate an Atlas instance using the AtlasContainer.\n\n\nThe container accepts a \nPDO\n, \nExtendedPdo\n or \nConnectionLocator\n instance or you \ncan enter connection parameters and the container creates a connection for you.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nPDO\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nExtendedPdo\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\nnew\n \nConnectionLocator\n(\n...\n));\n\n\n// or\n\n\n$atlasContainer\n \n=\n \nnew\n \nAtlasContainer\n(\n\n    \nmysql:host=localhost;dbname=testdb\n,\n\n    \nusername\n,\n\n    \npassword\n\n\n);\n\n\n\n\n\n\n\nNext, set the available mapper classes into the container.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$atlasContainer\n-\nsetMappers\n([\n\n    \nAuthorMapper\n::\nCLASS\n,\n\n    \nReplyMapper\n::\nCLASS\n,\n\n    \nSummaryMapper\n::\nCLASS\n,\n\n    \nTagMapper\n::\nCLASS\n,\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \nTaggingMapper\n::\nCLASS\n,\n\n\n]);\n\n\n\n\n\n\n\nFinally, get back the Atlas instance out of the container.\n\n\n1\n2\n?php\n\n\n$atlas\n \n=\n \n$atlasContainer\n-\ngetAtlas\n();", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "This package is installable and autoloadable via  Composer \nas  atlas/orm . Add the following lines\nto your  composer.json  file, then call  composer update .  1\n2\n3\n4\n5\n6\n7\n8 { \n     require :   { \n         atlas/orm :   ~1.0 \n     }, \n     require-dev :   { \n         atlas/cli :   ~1.0 \n     }  }    (The  atlas/cli  package provides the  atlas-skeleton  command-line tool to\nhelp create skeleton classes for the mapper.)", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#creating-data-source-classes", 
            "text": "You can create your data source classes by hand, but it's going to be tedious to\ndo so. Instead, use the  atlas-skeleton  command to read the table information\nfrom the database. You can read more about that in the atlas/cli docs .", 
            "title": "Creating Data Source Classes"
        }, 
        {
            "location": "/getting-started/#instantiating-atlas", 
            "text": "Create an Atlas instance using the AtlasContainer.  The container accepts a  PDO ,  ExtendedPdo  or  ConnectionLocator  instance or you \ncan enter connection parameters and the container creates a connection for you.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  $atlasContainer   =   new   AtlasContainer ( new   PDO ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( new   ExtendedPdo ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( new   ConnectionLocator ( ... ));  // or  $atlasContainer   =   new   AtlasContainer ( \n     mysql:host=localhost;dbname=testdb , \n     username , \n     password  );    Next, set the available mapper classes into the container.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $atlasContainer - setMappers ([ \n     AuthorMapper :: CLASS , \n     ReplyMapper :: CLASS , \n     SummaryMapper :: CLASS , \n     TagMapper :: CLASS , \n     ThreadMapper :: CLASS , \n     TaggingMapper :: CLASS ,  ]);    Finally, get back the Atlas instance out of the container.  1\n2 ?php  $atlas   =   $atlasContainer - getAtlas ();", 
            "title": "Instantiating Atlas"
        }, 
        {
            "location": "/relationships/", 
            "text": "Mapper Relationships\n\n\nYou can add relationships to a mapper inside its \nsetRelated()\n method, calling\none of the four available relationship-definition methods:\n\n\n\n\noneToOne($field, $mapperClass)\n (aka \"has one\")\n\n\nmanyToOne($field, $mapperClass)\n (aka \"belongs to\")\n\n\noneToMany($field, $mapperClass)\n (aka \"has many\")\n\n\nmanyToMany($field, $mapperClass, $throughField)\n (aka \"has many through\")\n\n\n\n\nThe \n$field\n will become a field name on the returned Record object. That field\nwill be populated from the specified \n$mapperClass\n in Atlas. (In the case of\n\nmanyToMany()\n, the association mappings will come from the specified\n\n$throughField\n.)\n\n\nHere is an example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n?php\n\n\nnamespace\n \nApp\\DataSource\\Thread\n;\n\n\n\nuse\n \nApp\\DataSource\\Author\\AuthorMapper\n;\n\n\nuse\n \nApp\\DataSource\\Summary\\SummaryMapper\n;\n\n\nuse\n \nApp\\DataSource\\Reply\\ReplyMapper\n;\n\n\nuse\n \nApp\\DataSource\\Tagging\\TaggingMapper\n;\n\n\nuse\n \nApp\\DataSource\\Tag\\TagMapper\n;\n\n\nuse\n \nAtlas\\Orm\\Mapper\\AbstractMapper\n;\n\n\n\nclass\n \nThreadMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\nmanyToOne\n(\nauthor\n,\n \nAuthorMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToOne\n(\nsummary\n,\n \nSummaryMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToMany\n(\nreplies\n,\n \nReplyMapper\n::\nCLASS\n);\n\n        \n$this\n-\noneToMany\n(\ntaggings\n,\n \nTaggingMapper\n::\nCLASS\n);\n\n        \n$this\n-\nmanyToMany\n(\ntags\n,\n \nTagMapper\n::\nCLASS\n,\n \ntaggings\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nRelationship Key Columns\n\n\nBy default, in all relationships except many-to-one, the relationship will take\nthe primary key column(s) in the native table, and map to those same column\nnames in the foreign table.\n\n\nIn the case of many-to-one, it is the reverse; that is, the relationship will\ntake the primary key column(s) in the foreign table, and map to those same\ncolumn names in the native table.\n\n\nIf you want to use different columns, call the \non()\n method on the\nrelationship. For example, if the threads table uses \nauthor_id\n, but the\nauthors table uses just \nid\n, you can do this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nThreadMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\nmanyToOne\n(\nauthor\n,\n \nAuthorMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (threads) column =\n foreign (authors) column\n\n                \nauthor_id\n \n=\n \nid\n,\n\n            \n]);\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nAnd on the \noneToMany\n side of the relationship, you use the native author table\n\nid\n column with the foreign threads table \nauthor_id\n column.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nAuthorMapper\n \nextends\n \nAbstractMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nposts\n,\n \nPostsMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (author) column =\n foreign (threads) column\n\n                \nid\n \n=\n \nauthor_id\n,\n\n            \n]);\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nComposite Relationship Keys\n\n\nLikewise, if a table uses a composite key, you can re-map the relationship on\nmultiple columns. If table \nfoo\n has composite primary key columns of \nacol\n and\n\nbcol\n, and it maps to table \nbar\n on \nfoo_acol\n and \nfoo_bcol\n, you would do\nthis:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nclass\n \nFooMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nbars\n,\n \nBarMapper\n::\nCLASS\n)\n\n            \n-\non\n([\n\n                \n// native (foo) column =\n foreign (bar) column\n\n                \nacol\n \n=\n \nfoo_acol\n,\n\n                \nbcol\n \n=\n \nfoo_bcol\n,\n\n            \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nCase-Sensitivity\n\n\n\n\nN.b.: This applies only to \nstring-based\n relationship keys. If you are\nusing numeric relationship keys, this section does not apply.\n\n\n\n\nAtlas will match records related by string keys in a case-senstive manner. If\nyour collations on the related string key columns are \nnot\n case sensitive,\nAtlas might not match up related records properly in memory after fetching them\nfrom the database. This is because 'foo' and 'FOO' might be equivalent in the\ndatabase collation, but they are \nnot\n equivalent in PHP.\n\n\nIn that kind of situation, you will want to tell the relationship to ignore the\ncase of related string key columns when matching related records. You can do so\nwith the \nignoreCase()\n method on the relationship definition.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\nclass\n \nFooMapper\n\n\n{\n\n    \nprotected\n \nfunction\n \nsetRelated\n()\n\n    \n{\n\n        \n$this\n-\noneToMany\n(\nbars\n,\n \nBarMapper\n::\nCLASS\n)\n\n            \n-\nignoreCase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nWith that in place, a native value of 'foo' match to a foreign value of 'FOO'\nwhen Atlas is stitching together related records.\n\n\nSimple WHERE Conditions\n\n\nYou may find it useful to define simple WHERE conditions on the foreign side of\nthe relationship. For example, you can handle one side of a so-called\npolymorphic relationship by selecting only related records of a particular type.\n\n\nIn the following example, a \ncomments\n table has a \ncommentable_id\n column as\nthe foreign key value, but is restricted to \"issue\" values on a discriminator\ncolumn named \ncommentable\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nclass IssueMapper extends AbstractMapper\n\n\n{\n\n\n    protected function setRelated()\n\n\n    {\n\n\n        $this-\noneToMany(\ncomments\n, CommentMapper::CLASS)\n\n\n            -\non([\n\n\n                \nissue_id\n =\n \ncommentable_id\n\n\n            ])\n\n\n            -\nwhere(\ncommentable = ?\n, \nissue\n);\n\n\n    }\n\n\n}\n\n\n\n\n\n\n\n(These conditions will be honored by \nMapperSelect::*joinWith()\n as well.)", 
            "title": "Mapper Relationships"
        }, 
        {
            "location": "/relationships/#mapper-relationships", 
            "text": "You can add relationships to a mapper inside its  setRelated()  method, calling\none of the four available relationship-definition methods:   oneToOne($field, $mapperClass)  (aka \"has one\")  manyToOne($field, $mapperClass)  (aka \"belongs to\")  oneToMany($field, $mapperClass)  (aka \"has many\")  manyToMany($field, $mapperClass, $throughField)  (aka \"has many through\")   The  $field  will become a field name on the returned Record object. That field\nwill be populated from the specified  $mapperClass  in Atlas. (In the case of manyToMany() , the association mappings will come from the specified $throughField .)  Here is an example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ?php  namespace   App\\DataSource\\Thread ;  use   App\\DataSource\\Author\\AuthorMapper ;  use   App\\DataSource\\Summary\\SummaryMapper ;  use   App\\DataSource\\Reply\\ReplyMapper ;  use   App\\DataSource\\Tagging\\TaggingMapper ;  use   App\\DataSource\\Tag\\TagMapper ;  use   Atlas\\Orm\\Mapper\\AbstractMapper ;  class   ThreadMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - manyToOne ( author ,   AuthorMapper :: CLASS ); \n         $this - oneToOne ( summary ,   SummaryMapper :: CLASS ); \n         $this - oneToMany ( replies ,   ReplyMapper :: CLASS ); \n         $this - oneToMany ( taggings ,   TaggingMapper :: CLASS ); \n         $this - manyToMany ( tags ,   TagMapper :: CLASS ,   taggings ); \n     }  }", 
            "title": "Mapper Relationships"
        }, 
        {
            "location": "/relationships/#relationship-key-columns", 
            "text": "By default, in all relationships except many-to-one, the relationship will take\nthe primary key column(s) in the native table, and map to those same column\nnames in the foreign table.  In the case of many-to-one, it is the reverse; that is, the relationship will\ntake the primary key column(s) in the foreign table, and map to those same\ncolumn names in the native table.  If you want to use different columns, call the  on()  method on the\nrelationship. For example, if the threads table uses  author_id , but the\nauthors table uses just  id , you can do this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   ThreadMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - manyToOne ( author ,   AuthorMapper :: CLASS ) \n             - on ([ \n                 // native (threads) column =  foreign (authors) column \n                 author_id   =   id , \n             ]); \n         // ... \n     }  }    And on the  oneToMany  side of the relationship, you use the native author table id  column with the foreign threads table  author_id  column.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   AuthorMapper   extends   AbstractMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( posts ,   PostsMapper :: CLASS ) \n             - on ([ \n                 // native (author) column =  foreign (threads) column \n                 id   =   author_id , \n             ]); \n         // ... \n     }  }", 
            "title": "Relationship Key Columns"
        }, 
        {
            "location": "/relationships/#composite-relationship-keys", 
            "text": "Likewise, if a table uses a composite key, you can re-map the relationship on\nmultiple columns. If table  foo  has composite primary key columns of  acol  and bcol , and it maps to table  bar  on  foo_acol  and  foo_bcol , you would do\nthis:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  class   FooMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( bars ,   BarMapper :: CLASS ) \n             - on ([ \n                 // native (foo) column =  foreign (bar) column \n                 acol   =   foo_acol , \n                 bcol   =   foo_bcol , \n             ]); \n     }  }", 
            "title": "Composite Relationship Keys"
        }, 
        {
            "location": "/relationships/#case-sensitivity", 
            "text": "N.b.: This applies only to  string-based  relationship keys. If you are\nusing numeric relationship keys, this section does not apply.   Atlas will match records related by string keys in a case-senstive manner. If\nyour collations on the related string key columns are  not  case sensitive,\nAtlas might not match up related records properly in memory after fetching them\nfrom the database. This is because 'foo' and 'FOO' might be equivalent in the\ndatabase collation, but they are  not  equivalent in PHP.  In that kind of situation, you will want to tell the relationship to ignore the\ncase of related string key columns when matching related records. You can do so\nwith the  ignoreCase()  method on the relationship definition.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  class   FooMapper  { \n     protected   function   setRelated () \n     { \n         $this - oneToMany ( bars ,   BarMapper :: CLASS ) \n             - ignoreCase (); \n     }  }    With that in place, a native value of 'foo' match to a foreign value of 'FOO'\nwhen Atlas is stitching together related records.", 
            "title": "Case-Sensitivity"
        }, 
        {
            "location": "/relationships/#simple-where-conditions", 
            "text": "You may find it useful to define simple WHERE conditions on the foreign side of\nthe relationship. For example, you can handle one side of a so-called\npolymorphic relationship by selecting only related records of a particular type.  In the following example, a  comments  table has a  commentable_id  column as\nthe foreign key value, but is restricted to \"issue\" values on a discriminator\ncolumn named  commentable .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 class IssueMapper extends AbstractMapper  {      protected function setRelated()      {          $this- oneToMany( comments , CommentMapper::CLASS)              - on([                   issue_id  =   commentable_id              ])              - where( commentable = ? ,  issue );      }  }    (These conditions will be honored by  MapperSelect::*joinWith()  as well.)", 
            "title": "Simple WHERE Conditions"
        }, 
        {
            "location": "/reading/", 
            "text": "Fetching Records and RecordSets\n\n\nUse Atlas to retrieve a single Record, or many Records in a RecordSet, from the database.\n\n\nFetching a Record\n\n\nUse the \nfetchRecord()\n method to retrieve a single Record. It can be called\neither by primary key, or with a \nselect()\n query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n// fetch by primary key thread_id = 1\n\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nclass\n,\n\n    \n1\n\n\n);\n\n\n\n$threadRecord\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n1\n)\n\n    \n-\nfetchRecord\n();\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe \nselect()\n variation gives you access to all the underlying\nSQL query methods. See \nAura\\SqlQuery\n\nfor more information.\n\n\n\n\n\n\nNote\n\n\nIf \nfetchRecord()\n does not find a match, it will return \nfalse\n.\n\n\n\n\n\n\nWarning\n\n\nIf using the \nselect()\n variation with the \ncols()\n method, be sure to include\nthe table's primary key column(s) if you are fetching a Record. If using one\nof the other \nfetch*()\n methods outlined in the chapter on Direct Queries,\nthen this isn't necessary. See below.\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\n// must include the primary key column (and author_id because of the\n\n\n// where clause)\n\n\n$threadRecord\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nauthor_id = ?\n,\n \n2\n)\n\n    \n-\ncols\n([\nthread_id\n,\n \ntitle\n,\n \nauthor_id\n])\n\n    \n-\nfetchRecord\n();\n\n\n\n// No need to include the primary key column\n\n\n$threadRecord\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nauthor_id = ?\n,\n \n2\n)\n\n    \n-\ncols\n([\ntitle\n,\n \nauthor_id\n])\n\n    \n-\nfetchOne\n();\n\n\n\n\n\n\n\nAccessing/Reading Record Data\n\n\nOnce you have a Record, you can access the columns via properties on the Record.\nAssume a database column called \ntitle\n.\n\n\n1\n2\n?php\n\n\necho\n \n$thread\n-\ntitle\n;\n\n\n\n\n\n\n\nFetching A RecordSet\n\n\nThe \nfetchRecordSet()\n method works the same as \nfetchRecord()\n, but for\nmultiple Records.  It can be called either with primary keys, or with a\n\nselect()\n query.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n// fetch thread_id 1, 2, and 3\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n);\n\n\n\n// This is identical to the example above, but uses the `select()` variation.\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\nthread_id IN (?)\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\nTo return all rows, use the \nselect()\n variation as shown below.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\n// Use the `select()` variation to fetch all records, optionally ordering the\n\n\n// returned results\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\norderBy\n([\ndate_added DESC\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe \nselect()\n variation gives you access to all the underlying\nSQL query methods. See \nAura\\SqlQuery\n\nfor more information.\n\n\n\n\n\n\nNote\n\n\nIf \nfetchRecordSet()\n does not find any matches, it will\nreturn an empty array. This is important as you cannot call RecordSet methods\n(see later in the documentation) such as \nappendNew()\n or \ngetArrayCopy()\n on\nan empty array. In these situations, you must test for the empty array, and then\ninstantiate a new RecordSet, if necessary. See below.\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n?php\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n);\n\n\nif\n \n(\n!\n \n$threadRecordSet\n)\n \n{\n\n    \n$threadRecordSet\n \n=\n \n$atlas\n-\nnewRecordSet\n(\nThreadMapper\n::\nCLASS\n);\n\n\n}\n\n\n\n$threadMapper\n-\nappendNew\n(\n...\n);\n\n\n\n\n\n\n\nAccessing/Reading RecordSet Data\n\n\nRecordSets act as arrays of Records. As such, you can easily iterate over the\nRecordSet and access the Records individually.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n// fetch the top 100 threads\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\norderBy\n([\nthread_id DESC\n])\n\n    \n-\nlimit\n(\n100\n)\n\n    \n-\nfetchRecordSet\n();\n\n\n\nforeach\n \n(\n$threadRecordSet\n \nas\n \n$threadRecord\n)\n \n{\n\n    \necho\n \n$threadRecord\n-\ntitle\n;\n\n\n}\n\n\n\n\n\n\n\nFetching Related Records\n\n\nAny relationships that are set in the Mapper will appear as \nNULL\n in the Record\nobject.  Related data will only be populated if it is explicitly requested as part\nof the fetch or select.\n\n\nOn a \nfetch*()\n, load relateds using a third argument: an array specifying\nwhich related fields to retrieve.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n]\n\n\n);\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nWhen using the \nselect()\n variation, load relateds using the \nwith()\n method:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n1\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n])\n\n    \n-\nfetchRecord\n();\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\nthread_id IN (?)\n,\n \n[\n1\n,\n \n2\n,\n \n3\n])\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n,\n\n    \n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n\n\n\n\n\n\nNote\n\n\nWhen fetching a \nmanyToMany\n relationship, you must explicitly specify\nboth the association (join) table AND the \nmanyToMany\n table. Additionally, you\nmust specify these relationships in the correct order.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \ntaggings\n,\n \n// specify the join table first\n\n        \ntags\n \n// then the manyToMany table\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nRelationships can be nested as deeply as needed. For example, to fetch the\nauthor of each reply on each thread:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n$threadRecord\n \n=\n \n$this\n-\natlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n$threadId\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \n[\n\n            \nauthor\n\n        \n]\n\n    \n])\n\n    \n-\nfetchRecord\n();\n\n\n\n\n\n\n\nAlternatively, you can pass a closure to exercise fine control over the query\nthat fetches the relateds:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n?php\n\n\n// fetch thread_id 1; with only the last 10 related replies in descending order;\n\n\n// including each reply author\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\n\n    \nThreadMapper\n::\nCLASS\n,\n\n    \n1\n,\n\n    \n[\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \nfunction\n \n(\n$selectReplies\n)\n \n{\n\n            \n$selectReplies\n\n                \n-\nlimit\n(\n10\n)\n\n                \n-\norderBy\n([\nreply_id DESC\n])\n\n                \n-\nwith\n([\n\n                    \nauthor\n\n                \n]);\n\n        \n},\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nAccessing/Reading Related Data\n\n\nAccessing related data works just like accessing Record properties except instead\nof using a column name, you use the relationship name defined in the mapper.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n?php\n\n\n$threadRecord\n \n=\n \n$this\n-\natlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nclass\n)\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n$threadId\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n \n=\n \n[\n\n            \nauthor\n\n        \n]\n\n    \n])\n\n    \n-\nfetchRecord\n();\n\n\n\n// Assume the author table has a column named `last_name`\n\n\nforeach\n \n(\n$threadRecord\n-\nreplies\n \nas\n \n$reply\n)\n \n{\n\n    \necho\n \n$reply\n-\nauthor\n-\nlast_name\n;\n\n\n}\n\n\n\n\n\n\n\nReturning Data in Other Formats\n\n\nYou can return a Record or a RecordSet as an \narray\n rather than a Record or\nRecordSet object using the \ngetArrayCopy()\n method.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n?php\n\n\n$threadRecord\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper::CLASS\n,\n \n1\n);\n\n\n$threadArray\n \n=\n \n$threadRecord\n-\ngetArrayCopy\n();\n\n\n\n$threadRecordSet\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\norderBy\n([\ndate_added DESC\n])\n\n    \n-\nfetchRecordSet\n();\n\n\n\n$threadsArray\n \n=\n \n$threadRecordSet\n-\ngetArrayCopy\n();\n\n\n\n\n\n\n\nJSON-encoding Records and RecordSets is trival.\n\n\n1\n2\n3\n?php\n\n\n$threadJson\n \n=\n \njson_encode\n(\n$threadRecord\n);\n\n\n$threadsJson\n \n=\n \njson_encode\n(\n$threadRecordSet\n);\n\n\n\n\n\n\n\nReading Record Counts\n\n\nIf you use a \nselect()\n to fetch a RecordSet with a \nlimit()\n or \npage()\n, you\ncan re-use the select to get a count of how many Records would have been\nreturned. This can be useful for paging displays.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\n$select\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwith\n([\n\n        \nauthor\n,\n\n        \nsummary\n,\n\n        \nreplies\n\n    \n])\n\n    \n-\nlimit\n(\n10\n)\n\n    \n-\noffset\n(\n20\n);\n\n\n\n$threadRecordSet\n \n=\n \n$select\n-\nfetchRecordSet\n();\n\n\n$countOfAllThreads\n \n=\n \n$select\n-\nfetchCount\n();", 
            "title": "Fetching Records and RecordSets"
        }, 
        {
            "location": "/reading/#fetching-records-and-recordsets", 
            "text": "Use Atlas to retrieve a single Record, or many Records in a RecordSet, from the database.", 
            "title": "Fetching Records and RecordSets"
        }, 
        {
            "location": "/reading/#fetching-a-record", 
            "text": "Use the  fetchRecord()  method to retrieve a single Record. It can be called\neither by primary key, or with a  select()  query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  // fetch by primary key thread_id = 1  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: class , \n     1  );  $threadRecord   =   $atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   1 ) \n     - fetchRecord ();     Tip  The  select()  variation gives you access to all the underlying\nSQL query methods. See  Aura\\SqlQuery \nfor more information.    Note  If  fetchRecord()  does not find a match, it will return  false .    Warning  If using the  select()  variation with the  cols()  method, be sure to include\nthe table's primary key column(s) if you are fetching a Record. If using one\nof the other  fetch*()  methods outlined in the chapter on Direct Queries,\nthen this isn't necessary. See below.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  // must include the primary key column (and author_id because of the  // where clause)  $threadRecord   =   $atlas \n     - select ( ThreadMapper :: class ) \n     - where ( author_id = ? ,   2 ) \n     - cols ([ thread_id ,   title ,   author_id ]) \n     - fetchRecord ();  // No need to include the primary key column  $threadRecord   =   $atlas \n     - select ( ThreadMapper :: class ) \n     - where ( author_id = ? ,   2 ) \n     - cols ([ title ,   author_id ]) \n     - fetchOne ();", 
            "title": "Fetching a Record"
        }, 
        {
            "location": "/reading/#accessingreading-record-data", 
            "text": "Once you have a Record, you can access the columns via properties on the Record.\nAssume a database column called  title .  1\n2 ?php  echo   $thread - title ;", 
            "title": "Accessing/Reading Record Data"
        }, 
        {
            "location": "/reading/#fetching-a-recordset", 
            "text": "The  fetchRecordSet()  method works the same as  fetchRecord() , but for\nmultiple Records.  It can be called either with primary keys, or with a select()  query.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  // fetch thread_id 1, 2, and 3  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ]  );  // This is identical to the example above, but uses the `select()` variation.  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - where ( thread_id IN (?) ,   [ 1 ,   2 ,   3 ]) \n     - fetchRecordSet ();    To return all rows, use the  select()  variation as shown below.  1\n2\n3\n4\n5\n6\n7\n8 ?php  // Use the `select()` variation to fetch all records, optionally ordering the  // returned results  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - orderBy ([ date_added DESC ]) \n     - fetchRecordSet ();     Tip  The  select()  variation gives you access to all the underlying\nSQL query methods. See  Aura\\SqlQuery \nfor more information.    Note  If  fetchRecordSet()  does not find any matches, it will\nreturn an empty array. This is important as you cannot call RecordSet methods\n(see later in the documentation) such as  appendNew()  or  getArrayCopy()  on\nan empty array. In these situations, you must test for the empty array, and then\ninstantiate a new RecordSet, if necessary. See below.    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ?php  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ]  );  if   ( !   $threadRecordSet )   { \n     $threadRecordSet   =   $atlas - newRecordSet ( ThreadMapper :: CLASS );  }  $threadMapper - appendNew ( ... );", 
            "title": "Fetching A RecordSet"
        }, 
        {
            "location": "/reading/#accessingreading-recordset-data", 
            "text": "RecordSets act as arrays of Records. As such, you can easily iterate over the\nRecordSet and access the Records individually.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  // fetch the top 100 threads  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - orderBy ([ thread_id DESC ]) \n     - limit ( 100 ) \n     - fetchRecordSet ();  foreach   ( $threadRecordSet   as   $threadRecord )   { \n     echo   $threadRecord - title ;  }", 
            "title": "Accessing/Reading RecordSet Data"
        }, 
        {
            "location": "/reading/#fetching-related-records", 
            "text": "Any relationships that are set in the Mapper will appear as  NULL  in the Record\nobject.  Related data will only be populated if it is explicitly requested as part\nof the fetch or select.  On a  fetch*() , load relateds using a third argument: an array specifying\nwhich related fields to retrieve.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         author , \n         summary , \n         replies , \n     ]  );  $threadRecordSet   =   $atlas - fetchRecordSet ( \n     ThreadMapper :: CLASS , \n     [ 1 ,   2 ,   3 ], \n     [ \n         author , \n         summary , \n         replies , \n     ]  );    When using the  select()  variation, load relateds using the  with()  method:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 ?php  $threadRecord   =   $atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   1 ) \n     - with ([ \n         author , \n         summary , \n         replies , \n     ]) \n     - fetchRecord ();  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - where ( thread_id IN (?) ,   [ 1 ,   2 ,   3 ]) \n     - with ([ \n         author , \n         summary , \n         replies , \n     ]) \n     - fetchRecordSet ();     Note  When fetching a  manyToMany  relationship, you must explicitly specify\nboth the association (join) table AND the  manyToMany  table. Additionally, you\nmust specify these relationships in the correct order.   1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         taggings ,   // specify the join table first \n         tags   // then the manyToMany table \n     ]  );    Relationships can be nested as deeply as needed. For example, to fetch the\nauthor of each reply on each thread:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  $threadRecord   =   $this - atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   $threadId ) \n     - with ([ \n         author , \n         summary , \n         replies   =   [ \n             author \n         ] \n     ]) \n     - fetchRecord ();    Alternatively, you can pass a closure to exercise fine control over the query\nthat fetches the relateds:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 ?php  // fetch thread_id 1; with only the last 10 related replies in descending order;  // including each reply author  $threadRecord   =   $atlas - fetchRecord ( \n     ThreadMapper :: CLASS , \n     1 , \n     [ \n         author , \n         summary , \n         replies   =   function   ( $selectReplies )   { \n             $selectReplies \n                 - limit ( 10 ) \n                 - orderBy ([ reply_id DESC ]) \n                 - with ([ \n                     author \n                 ]); \n         }, \n     ]  );", 
            "title": "Fetching Related Records"
        }, 
        {
            "location": "/reading/#accessingreading-related-data", 
            "text": "Accessing related data works just like accessing Record properties except instead\nof using a column name, you use the relationship name defined in the mapper.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 ?php  $threadRecord   =   $this - atlas \n     - select ( ThreadMapper :: class ) \n     - where ( thread_id = ? ,   $threadId ) \n     - with ([ \n         author , \n         summary , \n         replies   =   [ \n             author \n         ] \n     ]) \n     - fetchRecord ();  // Assume the author table has a column named `last_name`  foreach   ( $threadRecord - replies   as   $reply )   { \n     echo   $reply - author - last_name ;  }", 
            "title": "Accessing/Reading Related Data"
        }, 
        {
            "location": "/reading/#returning-data-in-other-formats", 
            "text": "You can return a Record or a RecordSet as an  array  rather than a Record or\nRecordSet object using the  getArrayCopy()  method.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ?php  $threadRecord   =   $atlas - fetchRecord ( ThreadMapper::CLASS ,   1 );  $threadArray   =   $threadRecord - getArrayCopy ();  $threadRecordSet   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - orderBy ([ date_added DESC ]) \n     - fetchRecordSet ();  $threadsArray   =   $threadRecordSet - getArrayCopy ();    JSON-encoding Records and RecordSets is trival.  1\n2\n3 ?php  $threadJson   =   json_encode ( $threadRecord );  $threadsJson   =   json_encode ( $threadRecordSet );", 
            "title": "Returning Data in Other Formats"
        }, 
        {
            "location": "/reading/#reading-record-counts", 
            "text": "If you use a  select()  to fetch a RecordSet with a  limit()  or  page() , you\ncan re-use the select to get a count of how many Records would have been\nreturned. This can be useful for paging displays.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  $select   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - with ([ \n         author , \n         summary , \n         replies \n     ]) \n     - limit ( 10 ) \n     - offset ( 20 );  $threadRecordSet   =   $select - fetchRecordSet ();  $countOfAllThreads   =   $select - fetchCount ();", 
            "title": "Reading Record Counts"
        }, 
        {
            "location": "/records/", 
            "text": "Working with Records\n\n\nCreating and Inserting a Record\n\n\nCreate a new Record using the \nnewRecord()\n method. You can assign data using\nproperties, or pass an array of initial data to populate into the Record.\n\n\n1\n2\n3\n4\n5\n6\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n    \n]\n\n\n);\n\n\n\n\n\n\n\nYou can assign a value via a property, which maps to a column name.\n\n\n1\n2\n$date = new \\DateTime();\n\n\n$thread-\ndate_added = $date-\nformat(\nY-m-d H:i:s\n);\n\n\n\n\n\n\n\nYou can insert a single Record back to the database by using the \nAtlas::insert()\n\nmethod. This will use the appropriate Mapper for the Record to perform the\nwrite within a transaction, and capture any exceptions that occur along the way.\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nInserting a Record with an auto-incrementing primary key will automatically\nmodify the Record to set the last-inserted ID.\n\n\nInserting a Record will automatically set the foreign key fields on the native\nRecord, and on all the loaded relationships for that Record.\n\n\nIn the following example, assume a Thread Record has a \nmanyToOne\n relationship\nwith an Author Record using the \nauthor_id\n column. The relationship is named\n\nauthor\n. (See the section on relationships for more information.)\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\n$author\n \n=\n \n$atlas\n-\nfetchRecord\n(\nAuthorMapper\n::\nCLASS\n,\n \n4\n);\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n        \nauthor\n=\n$author\n\n    \n]\n\n\n);\n\n\n// If the insert is successful, the `author_id` column will automatically be\n\n\n// set to the Author Record\ns primary key value. In this case, 4.\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\n\necho\n \n$thread\n-\nauthor_id\n;\n \n// 4\n\n\n\n\n\n\n\n\n\nNote\n\n\nIf the Author Record is new, Atlas will NOT automatically insert the\nnew Author and set the foreign key on the new Author Record via the \ninsert()\n\nmethod. This can, however, be achieved using the \npersist()\n method. This is\ndiscussed later in this chapter.\n\n\n\n\nThe following will fail.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\n$author\n \n=\n \n$atlas\n-\nnewRecord\n(\nAuthorMapper\n::\nCLASS\n,\n\n    \n[\n\n        \nfirst_name\n=\nSterling\n,\n\n        \nlast_name\n=\nArcher\n\n    \n]\n\n\n);\n\n\n$thread\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n,\n\n    \n[\n\n        \ntitle\n=\nNew Thread Title\n,\n\n        \nauthor\n=\n$author\n\n    \n]\n\n\n);\n\n\n// Insert will not create the related Author Record. Use persist() instead.\n\n\n$success\n \n=\n \n$atlas\n-\ninsert\n(\n$thread\n);\n\n\n\n\n\n\n\nUpdating an Existing Record\n\n\nUpdating an existing record works the same as \ninsert()\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n?php\n\n\n// fetch an existing record by primary key\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n\n// Modify the title\n\n\n$thread\n-\ntitle\n \n=\n \nThis title is better than the last one\n;\n\n\n\n// Save the record back to the database.\n\n\n$success\n \n=\n \n$atlas\n-\nupdate\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nAs with \ninsert()\n, foreign keys are also updated, but only for existing related\nrecords.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n$author\n \n=\n \n$atlas\n-\nfetchRecord\n(\nAuthorMapper\n::\nCLASS\n,\n \n4\n);\n\n\n\n// Modify the author\n\n\n$thread\n-\nauthor\n \n=\n \n$author\n;\n\n\n\n// Save the record back to the database.\n\n\n$success\n \n=\n \n$atlas\n-\nupdate\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nDeleting a Record\n\n\nDeleting a record works the same as inserting or updating.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n\n$success\n \n=\n \n$atlas\n-\ndelete\n(\n$thread\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nRemoved record from the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not remove the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nPersisting a Record\n\n\nIf you like, you can persist a Record and all of its loaded relationships (and\nall of \ntheir\n loaded relationships, etc.) back to the database using the Atlas\n\npersist()\n method. This is good for straightforward relationship structures\nwhere the order of write operations does not need to be closely managed.\n\n\nThe \npersist()\n method will:\n\n\n\n\npersist many-to-one and many-to-many relateds loaded on the native Record;\n\n\npersist the native Record by ...\n\n\ninserting the Row for the Record if it is new; or,\n\n\nupdating the Row for the Record if it has been modified; or,\n\n\ndeleting the Row for the Record if the Record has been marked for deletion\n  using the Record::markForDeletion() method;\n\n\n\n\n\n\npersist one-to-one and one-to-many relateds loaded on the native Record.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n$success\n \n=\n \n$atlas\n-\npersist\n(\n$record\n);\n\n\nif\n \n(\n$success\n)\n \n{\n\n    \necho\n \nWrote the Record and all of its relateds back to the database.\n;\n\n\n}\n \nelse\n \n{\n\n    \necho\n \nDid not write the Record: \n \n.\n \n$atlas\n-\ngetException\n();\n\n\n}\n\n\n\n\n\n\n\nAs with insert and update, this will automatically set the foreign key fields on\nthe native Record, and on all the loaded relationships for that Record.\n\n\nIf a related field is not loaded, it cannot be persisted automatically.\n\n\nNote that whether or not the Row for the Record is inserted/updated/deleted, the\n\npersist()\n method will still recursively traverse all the related fields and\npersist them as well.\n\n\nThe \ndelete()\n method \nwill not\n attempt to cascade deletion or nullification\nacross relateds at the ORM level. Your database may have cascading set up at the\ndatabase level; Atlas has no control over this.\n\n\nMarking Records for Deletion\n\n\nYou may also mark records for deletion and they will be removed from the database\nafter a transaction is completed via \npersist()\n.\n\n\n1\n2\n3\n4\n5\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n);\n\n\n// Mark the record for deletion\n\n\n$thread\n-\nmarkForDeletion\n();\n\n\n$atlas\n-\npersist\n(\n$thread\n);\n\n\n\n\n\n\n\nYou can also mark several related Records for deletion and when the native\nRecord is persisted, they will be deleted from the database.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n?php\n\n\n// Assume a oneToMany relationship between a thread and its comments\n\n\n// Select the thread and related comments\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n3\n,\n\n    \n[\n\n        \ncomments\n\n    \n]\n\n\n);\n\n\n\n// Mark each related comment for deletion\n\n\nforeach\n \n(\n$thread\n-\ncomments\n \nas\n \n$comment\n)\n \n{\n\n    \n$comment\n-\nmarkForDeletion\n();\n\n\n}\n\n\n\n// Persist the thread and the comments are also deleted\n\n\n$atlas\n-\npersist\n(\n$thread\n);", 
            "title": "Working with Records"
        }, 
        {
            "location": "/records/#working-with-records", 
            "text": "", 
            "title": "Working with Records"
        }, 
        {
            "location": "/records/#creating-and-inserting-a-record", 
            "text": "Create a new Record using the  newRecord()  method. You can assign data using\nproperties, or pass an array of initial data to populate into the Record.  1\n2\n3\n4\n5\n6 ?php  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n     ]  );    You can assign a value via a property, which maps to a column name.  1\n2 $date = new \\DateTime();  $thread- date_added = $date- format( Y-m-d H:i:s );    You can insert a single Record back to the database by using the  Atlas::insert() \nmethod. This will use the appropriate Mapper for the Record to perform the\nwrite within a transaction, and capture any exceptions that occur along the way.  1\n2\n3\n4\n5\n6\n7 ?php  $success   =   $atlas - insert ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    Inserting a Record with an auto-incrementing primary key will automatically\nmodify the Record to set the last-inserted ID.  Inserting a Record will automatically set the foreign key fields on the native\nRecord, and on all the loaded relationships for that Record.  In the following example, assume a Thread Record has a  manyToOne  relationship\nwith an Author Record using the  author_id  column. The relationship is named author . (See the section on relationships for more information.)   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  $author   =   $atlas - fetchRecord ( AuthorMapper :: CLASS ,   4 );  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n         author = $author \n     ]  );  // If the insert is successful, the `author_id` column will automatically be  // set to the Author Record s primary key value. In this case, 4.  $success   =   $atlas - insert ( $thread );  echo   $thread - author_id ;   // 4     Note  If the Author Record is new, Atlas will NOT automatically insert the\nnew Author and set the foreign key on the new Author Record via the  insert() \nmethod. This can, however, be achieved using the  persist()  method. This is\ndiscussed later in this chapter.   The following will fail.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  $author   =   $atlas - newRecord ( AuthorMapper :: CLASS , \n     [ \n         first_name = Sterling , \n         last_name = Archer \n     ]  );  $thread   =   $atlas - newRecord ( ThreadMapper :: CLASS , \n     [ \n         title = New Thread Title , \n         author = $author \n     ]  );  // Insert will not create the related Author Record. Use persist() instead.  $success   =   $atlas - insert ( $thread );", 
            "title": "Creating and Inserting a Record"
        }, 
        {
            "location": "/records/#updating-an-existing-record", 
            "text": "Updating an existing record works the same as  insert() .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ?php  // fetch an existing record by primary key  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  // Modify the title  $thread - title   =   This title is better than the last one ;  // Save the record back to the database.  $success   =   $atlas - update ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    As with  insert() , foreign keys are also updated, but only for existing related\nrecords.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  $author   =   $atlas - fetchRecord ( AuthorMapper :: CLASS ,   4 );  // Modify the author  $thread - author   =   $author ;  // Save the record back to the database.  $success   =   $atlas - update ( $thread );  if   ( $success )   { \n     echo   Wrote the Record back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }", 
            "title": "Updating an Existing Record"
        }, 
        {
            "location": "/records/#deleting-a-record", 
            "text": "Deleting a record works the same as inserting or updating.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  $success   =   $atlas - delete ( $thread );  if   ( $success )   { \n     echo   Removed record from the database. ;  }   else   { \n     echo   Did not remove the Record:    .   $atlas - getException ();  }", 
            "title": "Deleting a Record"
        }, 
        {
            "location": "/records/#persisting-a-record", 
            "text": "If you like, you can persist a Record and all of its loaded relationships (and\nall of  their  loaded relationships, etc.) back to the database using the Atlas persist()  method. This is good for straightforward relationship structures\nwhere the order of write operations does not need to be closely managed.  The  persist()  method will:   persist many-to-one and many-to-many relateds loaded on the native Record;  persist the native Record by ...  inserting the Row for the Record if it is new; or,  updating the Row for the Record if it has been modified; or,  deleting the Row for the Record if the Record has been marked for deletion\n  using the Record::markForDeletion() method;    persist one-to-one and one-to-many relateds loaded on the native Record.   1\n2\n3\n4\n5\n6\n7 ?php  $success   =   $atlas - persist ( $record );  if   ( $success )   { \n     echo   Wrote the Record and all of its relateds back to the database. ;  }   else   { \n     echo   Did not write the Record:    .   $atlas - getException ();  }    As with insert and update, this will automatically set the foreign key fields on\nthe native Record, and on all the loaded relationships for that Record.  If a related field is not loaded, it cannot be persisted automatically.  Note that whether or not the Row for the Record is inserted/updated/deleted, the persist()  method will still recursively traverse all the related fields and\npersist them as well.  The  delete()  method  will not  attempt to cascade deletion or nullification\nacross relateds at the ORM level. Your database may have cascading set up at the\ndatabase level; Atlas has no control over this.", 
            "title": "Persisting a Record"
        }, 
        {
            "location": "/records/#marking-records-for-deletion", 
            "text": "You may also mark records for deletion and they will be removed from the database\nafter a transaction is completed via  persist() .  1\n2\n3\n4\n5 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 );  // Mark the record for deletion  $thread - markForDeletion ();  $atlas - persist ( $thread );    You can also mark several related Records for deletion and when the native\nRecord is persisted, they will be deleted from the database.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 ?php  // Assume a oneToMany relationship between a thread and its comments  // Select the thread and related comments  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   3 , \n     [ \n         comments \n     ]  );  // Mark each related comment for deletion  foreach   ( $thread - comments   as   $comment )   { \n     $comment - markForDeletion ();  }  // Persist the thread and the comments are also deleted  $atlas - persist ( $thread );", 
            "title": "Marking Records for Deletion"
        }, 
        {
            "location": "/record-sets/", 
            "text": "Working with RecordSets\n\n\nNew RecordSets\n\n\nCreate a new RecordSet using the \nnewRecordSet()\n method.\n\n\n1\n2\n?php\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nnewRecordSet\n(\nThreadMapper\n::\nCLASS\n);\n\n\n\n\n\n\n\nAppending Records to a RecordSet\n\n\nYou can append a new Record to an existing RecordSet using \nappendNew()\n, optionally passing any\ndata you want to initially populate into the Record:\n\n\n1\n2\n3\n4\n?php\n\n\n$newThread\n \n=\n \n$threadRecordSet\n-\nappendNew\n([\n\n    \ntitle\n \n=\n \nNew Title\n,\n\n\n]);\n\n\n\n\n\n\n\nAdditionally, you can append foreign Records to a native Record's relateds.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n?php\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n1\n,\n\n    \n[\n\n        \ncomments\n,\n\n    \n]\n\n\n);\n\n\n\n// Ensure we have a RecordSet to append to\n\n\nif\n \n(\n!\n \n$thread\n-\ncomments\n)\n \n{\n\n    \n$thread\n-\ncomments\n \n=\n \n$atlas\n-\nnewRecordSet\n(\nCommentMapper\n::\nCLASS\n);\n\n\n}\n\n\n\n$comment\n \n=\n \n$thread\n-\ncomments\n-\nappendNew\n([\n\n    \nthread_id\n \n=\n \n$thread\n-\nthread_id\n,\n\n    \ncomment\n \n=\n \nLorem ipsum dolor sit amet...\n\n\n]);\n\n\n\n// plan to insert the new comment\n\n\n$transaction\n-\ninsert\n(\n$comment\n);\n\n\n\n// Or persist the thread\n\n\n$atlas\n-\npersist\n(\n$thread\n);\n\n\n\n\n\n\n\nArray Access\n\n\nThe RecordSet also acts as an array, so you can get/set/unset Records by their\nsequential keys in the RecordSet.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n// address the second record in the set\n\n\n$threadRecordSet\n[\n1\n]\n-\ntitle\n \n=\n \nChanged Title\n;\n\n\n\n// unset the first record in the set\n\n\nunset\n(\n$threadRecordSet\n[\n0\n]);\n\n\n\n// push a new record onto the set\n\n\n$threadRecordSet\n[]\n \n=\n \n$atlas\n-\nnewRecord\n(\nThreadMapper\n::\nCLASS\n);\n\n\n\n\n\n\n\nSearching within RecordSets\n\n\nYou can search for Records within an existing RecordSet by their column values:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$threadRecordSet\n \n=\n \n$atlas\n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\nwhere\n(\npublished=?\n,\n \n1\n)\n\n    \n-\nfetchRecordSet\n();\n\n\n\n// returns one matching Record object from the RecordSet,\n\n\n// or false if there is no match\n\n\n$matchingRecord\n \n=\n \n$threadRecordSet\n-\ngetOneBy\n([\nsubject\n \n=\n \nSubject One\n]);\n\n\n\n// returns an array of matching Record objects from the RecordSet\n\n\n$matchingRecords\n \n=\n \n$threadRecordSet\n-\ngetAllBy\n([\nauthor_id\n \n=\n \n5\n]);\n\n\n\n\n\n\n\nRemoving Records from RecordSets\n\n\nYou can remove Records from a RecordSet by their column values. This does NOT\ndelete the Record from the database; only from the RecordSet.\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n// unsets and returns one matching Record from the Record Set,\n\n\n// or false if there is no match\n\n\n$removedRecord\n \n=\n \n$threadRecordSet\n-\nremoveOneBy\n([\nsubject\n \n=\n \nSubject One\n]);\n\n\n\n// unsets and returns an array of matching Record objects from the Record Set\n\n\n$removedRecords\n \n=\n \n$threadRecordSet\n-\nremoveAllBy\n([\nauthor_id\n \n=\n \n5\n]);\n\n\n\n\n\n\n\n\n\nNote\n\n\nThis only removes them from the RecordSet; it does not delete them\nfrom the database. If you need to delete a record from the database, see the\nsections on Marking Records for Deletion and deleting Records.", 
            "title": "Working with RecordSets"
        }, 
        {
            "location": "/record-sets/#working-with-recordsets", 
            "text": "", 
            "title": "Working with RecordSets"
        }, 
        {
            "location": "/record-sets/#new-recordsets", 
            "text": "Create a new RecordSet using the  newRecordSet()  method.  1\n2 ?php  $threadRecordSet   =   $atlas - newRecordSet ( ThreadMapper :: CLASS );", 
            "title": "New RecordSets"
        }, 
        {
            "location": "/record-sets/#appending-records-to-a-recordset", 
            "text": "You can append a new Record to an existing RecordSet using  appendNew() , optionally passing any\ndata you want to initially populate into the Record:  1\n2\n3\n4 ?php  $newThread   =   $threadRecordSet - appendNew ([ \n     title   =   New Title ,  ]);    Additionally, you can append foreign Records to a native Record's relateds.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 ?php  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   1 , \n     [ \n         comments , \n     ]  );  // Ensure we have a RecordSet to append to  if   ( !   $thread - comments )   { \n     $thread - comments   =   $atlas - newRecordSet ( CommentMapper :: CLASS );  }  $comment   =   $thread - comments - appendNew ([ \n     thread_id   =   $thread - thread_id , \n     comment   =   Lorem ipsum dolor sit amet...  ]);  // plan to insert the new comment  $transaction - insert ( $comment );  // Or persist the thread  $atlas - persist ( $thread );", 
            "title": "Appending Records to a RecordSet"
        }, 
        {
            "location": "/record-sets/#array-access", 
            "text": "The RecordSet also acts as an array, so you can get/set/unset Records by their\nsequential keys in the RecordSet.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  // address the second record in the set  $threadRecordSet [ 1 ] - title   =   Changed Title ;  // unset the first record in the set  unset ( $threadRecordSet [ 0 ]);  // push a new record onto the set  $threadRecordSet []   =   $atlas - newRecord ( ThreadMapper :: CLASS );", 
            "title": "Array Access"
        }, 
        {
            "location": "/record-sets/#searching-within-recordsets", 
            "text": "You can search for Records within an existing RecordSet by their column values:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $threadRecordSet   =   $atlas - select ( ThreadMapper :: CLASS ) \n     - where ( published=? ,   1 ) \n     - fetchRecordSet ();  // returns one matching Record object from the RecordSet,  // or false if there is no match  $matchingRecord   =   $threadRecordSet - getOneBy ([ subject   =   Subject One ]);  // returns an array of matching Record objects from the RecordSet  $matchingRecords   =   $threadRecordSet - getAllBy ([ author_id   =   5 ]);", 
            "title": "Searching within RecordSets"
        }, 
        {
            "location": "/record-sets/#removing-records-from-recordsets", 
            "text": "You can remove Records from a RecordSet by their column values. This does NOT\ndelete the Record from the database; only from the RecordSet.  1\n2\n3\n4\n5\n6\n7 ?php  // unsets and returns one matching Record from the Record Set,  // or false if there is no match  $removedRecord   =   $threadRecordSet - removeOneBy ([ subject   =   Subject One ]);  // unsets and returns an array of matching Record objects from the Record Set  $removedRecords   =   $threadRecordSet - removeAllBy ([ author_id   =   5 ]);     Note  This only removes them from the RecordSet; it does not delete them\nfrom the database. If you need to delete a record from the database, see the\nsections on Marking Records for Deletion and deleting Records.", 
            "title": "Removing Records from RecordSets"
        }, 
        {
            "location": "/transactions/", 
            "text": "Transactions (Unit of Work)\n\n\nIf you make changes to several Records, you can write them back to the database\nusing a unit-of-work Transaction. You can plan for Records to be inserted,\nupdated, and deleted, in whatever order you like, and then execute the entire\ntransaction plan at once. Exceptions will cause a rollback.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n?php\n\n\n// create a transaction\n\n\n$transaction\n \n=\n \n$atlas\n-\nnewTransaction\n();\n\n\n\n// plan work for the transaction\n\n\n$transaction\n-\ninsert\n(\n$record1\n);\n\n\n$transaction\n-\nupdate\n(\n$record2\n);\n\n\n$transaction\n-\ndelete\n(\n$record3\n);\n\n\n\n// or persist an entire record and its relateds\n\n\n$transaction\n-\npersist\n(\n$record4\n);\n\n\n\n// execute the transaction plan\n\n\n$success\n \n=\n \n$transaction\n-\nexec\n();\n\n\nif\n \n(\n$success\n)\n \n{\n\n\n    \necho\n \nThe Transaction succeeded!\n;\n\n\n\n}\n \nelse\n \n{\n\n\n    \n// get the exception that was thrown in the transaction\n\n    \n$e\n \n=\n \n$transaction\n-\ngetException\n();\n\n\n    \n// get the work element that threw the exception\n\n    \n$work\n \n=\n \n$transaction\n-\ngetFailure\n();\n\n\n    \n// some output\n\n    \necho\n \nThe Transaction failed: \n;\n\n    \necho\n \n$work\n-\ngetLabel\n()\n \n.\n \n threw \n \n.\n \n$e\n-\ngetMessage\n();\n\n\n}", 
            "title": "Transactions (Unit of Work)"
        }, 
        {
            "location": "/transactions/#transactions-unit-of-work", 
            "text": "If you make changes to several Records, you can write them back to the database\nusing a unit-of-work Transaction. You can plan for Records to be inserted,\nupdated, and deleted, in whatever order you like, and then execute the entire\ntransaction plan at once. Exceptions will cause a rollback.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 ?php  // create a transaction  $transaction   =   $atlas - newTransaction ();  // plan work for the transaction  $transaction - insert ( $record1 );  $transaction - update ( $record2 );  $transaction - delete ( $record3 );  // or persist an entire record and its relateds  $transaction - persist ( $record4 );  // execute the transaction plan  $success   =   $transaction - exec ();  if   ( $success )   { \n\n     echo   The Transaction succeeded! ;  }   else   { \n\n     // get the exception that was thrown in the transaction \n     $e   =   $transaction - getException (); \n\n     // get the work element that threw the exception \n     $work   =   $transaction - getFailure (); \n\n     // some output \n     echo   The Transaction failed:  ; \n     echo   $work - getLabel ()   .    threw    .   $e - getMessage ();  }", 
            "title": "Transactions (Unit of Work)"
        }, 
        {
            "location": "/logic/", 
            "text": "Adding Custom Logic to Records and RecordSets\n\n\nAtlas makes it easy to add your own logic to both Records and RecordSets. To\naccomplish this, you need a Record class for custom Record logic, and a\nRecordSet class for custom RecordSet logic. The Atlas CLI script\n(installable via composer using \natlas/cli\n), can create these classes for you,\nsaving you from manually writing them.\n\nAtlas CLI documentation\n\nis available on GitHub.\n\n\nHere is an example using the \natlas/cli\n package and the \n--full\n option.\n\n\n1\n2\n3\n4\n5\n6\n./vendor/bin/atlas-skeleton.php \\\n    --conn=/path/to/conn.php \\\n    --dir=src/App/DataSource \\\n    --table=threads \\\n    --full \\\n    App\\\\DataSource\\\\Thread\n\n\n\n\n\n\nUpon completion, you will have a folder layout as follows:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n-- src\n   -- App\n      -- DataSource\n         -- Thread\n            -- ThreadMapper.php\n            -- ThreadMapperEvents.php\n            -- ThreadRecord.php\n            -- ThreadRecordSet.php\n            -- ThreadTable.php\n            -- ThreadTableEvents.php\n\n\n\n\n\n\nOnce you have a Record Class (ThreadRecord.php), you can create custom methods\nto call from your Record object.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n?php\n\n\nnamespace\n \nApp\\DataSource\\Thread\n;\n\n\n\nuse\n \nAtlas\\Orm\\Mapper\\Record\n;\n\n\n\n/**\n\n\n * @inheritdoc\n\n\n */\n\n\nclass\n \nThreadRecord\n \nextends\n \nRecord\n\n\n{\n\n    \n// Format the date_created property\n\n    \npublic\n \nfunction\n \nformatDate\n(\n$format\n \n=\n \nM jS, Y\n)\n\n    \n{\n\n        \n$dateTime\n \n=\n \nnew\n \n\\DateTime\n(\n$this\n-\ndate_created\n);\n\n        \nreturn\n \n$dateTime\n-\nformat\n(\n$format\n);\n\n    \n}\n\n\n}\n\n\n$thread\n \n=\n \n$atlas\n-\nfetchRecord\n(\nThreadMapper\n::\nCLASS\n,\n \n$id\n);\n\n\necho\n \n$thread\n-\nformatDate\n();\n \n// outputs something like `Aug 21st, 2017`\n\n\n\n\n\n\n\nThe same concept is available for RecordSets using the RecordSet class. In our\nexample \nThreadRecordSet.php\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n?php\n\n\nnamespace\n \nApp\\DataSource\\Thread\n;\n\n\n\nuse\n \nAtlas\\Orm\\Mapper\\RecordSet\n;\n\n\n\n/**\n\n\n * @inheritdoc\n\n\n */\n\n\nclass\n \nThreadRecordSet\n \nextends\n \nRecordSet\n\n\n{\n\n    \npublic\n \nfunction\n \nfoo\n()\n\n    \n{\n\n        \n$data\n \n=\n \n[]\n\n        \nforeach\n \n(\n$this\n \nas\n \n$record\n)\n \n{\n\n            \n$data\n[]\n \n=\n \n$record\n-\ntitle\n;\n\n        \n}\n\n\n        \nreturn\n \nimplode\n(\n; \n,\n \n$data\n);\n\n    \n}\n\n\n}\n\n\n$threads\n \n=\n \n$atlas\n-\nfetchRecordSet\n(\nThreadMapper\n::\nCLASS\n,\n \n[\n1\n,\n \n2\n,\n \n3\n]);\n\n\n\necho\n \n$threads\n-\nfoo\n();", 
            "title": "Adding Logic to Records and RecordSets"
        }, 
        {
            "location": "/logic/#adding-custom-logic-to-records-and-recordsets", 
            "text": "Atlas makes it easy to add your own logic to both Records and RecordSets. To\naccomplish this, you need a Record class for custom Record logic, and a\nRecordSet class for custom RecordSet logic. The Atlas CLI script\n(installable via composer using  atlas/cli ), can create these classes for you,\nsaving you from manually writing them. Atlas CLI documentation \nis available on GitHub.  Here is an example using the  atlas/cli  package and the  --full  option.  1\n2\n3\n4\n5\n6 ./vendor/bin/atlas-skeleton.php \\\n    --conn=/path/to/conn.php \\\n    --dir=src/App/DataSource \\\n    --table=threads \\\n    --full \\\n    App\\\\DataSource\\\\Thread   Upon completion, you will have a folder layout as follows:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 -- src\n   -- App\n      -- DataSource\n         -- Thread\n            -- ThreadMapper.php\n            -- ThreadMapperEvents.php\n            -- ThreadRecord.php\n            -- ThreadRecordSet.php\n            -- ThreadTable.php\n            -- ThreadTableEvents.php   Once you have a Record Class (ThreadRecord.php), you can create custom methods\nto call from your Record object.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 ?php  namespace   App\\DataSource\\Thread ;  use   Atlas\\Orm\\Mapper\\Record ;  /**   * @inheritdoc   */  class   ThreadRecord   extends   Record  { \n     // Format the date_created property \n     public   function   formatDate ( $format   =   M jS, Y ) \n     { \n         $dateTime   =   new   \\DateTime ( $this - date_created ); \n         return   $dateTime - format ( $format ); \n     }  }  $thread   =   $atlas - fetchRecord ( ThreadMapper :: CLASS ,   $id );  echo   $thread - formatDate ();   // outputs something like `Aug 21st, 2017`    The same concept is available for RecordSets using the RecordSet class. In our\nexample  ThreadRecordSet.php .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 ?php  namespace   App\\DataSource\\Thread ;  use   Atlas\\Orm\\Mapper\\RecordSet ;  /**   * @inheritdoc   */  class   ThreadRecordSet   extends   RecordSet  { \n     public   function   foo () \n     { \n         $data   =   [] \n         foreach   ( $this   as   $record )   { \n             $data []   =   $record - title ; \n         } \n\n         return   implode ( ;  ,   $data ); \n     }  }  $threads   =   $atlas - fetchRecordSet ( ThreadMapper :: CLASS ,   [ 1 ,   2 ,   3 ]);  echo   $threads - foo ();", 
            "title": "Adding Custom Logic to Records and RecordSets"
        }, 
        {
            "location": "/events/", 
            "text": "Events\n\n\nRecord Events\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n?php\n\n\nnamespace\n \nBlog\\DataSource\\Posts\n;\n\n\n\nuse\n \nAtlas\\Orm\\Mapper\\MapperEvents\n;\n\n\nuse\n \nAtlas\\Orm\\Mapper\\MapperInterface\n;\n\n\nuse\n \nAtlas\\Orm\\Mapper\\RecordInterface\n;\n\n\nuse\n \nAtlas\\Orm\\Exception\n;\n\n\n\n/**\n\n\n * @inheritdoc\n\n\n */\n\n\nclass\n \nPostsMapperEvents\n \nextends\n \nMapperEvents\n\n\n{\n\n    \npublic\n \nfunction\n \nbeforeUpdate\n(\nMapperInterface\n \n$mapper\n,\n \nRecordInterface\n \n$record\n)\n\n    \n{\n\n        \n// Validate the record and throw an exception if not valid.\n\n        \n$required\n \n=\n \n[\n\n            \ntitle\n=\nPost title\n,\n\n            \nbody\n=\nPost body\n,\n\n            \nauthor_id\n=\nAuthor\n\n        \n];\n\n        \nforeach\n \n(\n$required\n \nas\n \n$field\n=\n$label\n)\n \n{\n\n            \nif\n \n(\n!\n \n$record\n-\n$field\n)\n \n{\n\n                \n$record\n-\naddError\n(\n$field\n,\n \n$label\n \n.\n \n can not be empty\n);\n\n            \n}\n\n        \n}\n\n\n        \nif\n \n(\ncount\n(\n$record\n-\ngetErrors\n())\n \n \n0\n)\n \n{\n\n            \nthrow\n \nnew\n \nException\n(\nUpdate Error\n);\n\n        \n}\n\n\n    \n}\n\n\n}", 
            "title": "Events"
        }, 
        {
            "location": "/events/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/events/#record-events", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 ?php  namespace   Blog\\DataSource\\Posts ;  use   Atlas\\Orm\\Mapper\\MapperEvents ;  use   Atlas\\Orm\\Mapper\\MapperInterface ;  use   Atlas\\Orm\\Mapper\\RecordInterface ;  use   Atlas\\Orm\\Exception ;  /**   * @inheritdoc   */  class   PostsMapperEvents   extends   MapperEvents  { \n     public   function   beforeUpdate ( MapperInterface   $mapper ,   RecordInterface   $record ) \n     { \n         // Validate the record and throw an exception if not valid. \n         $required   =   [ \n             title = Post title , \n             body = Post body , \n             author_id = Author \n         ]; \n         foreach   ( $required   as   $field = $label )   { \n             if   ( !   $record - $field )   { \n                 $record - addError ( $field ,   $label   .    can not be empty ); \n             } \n         } \n\n         if   ( count ( $record - getErrors ())     0 )   { \n             throw   new   Exception ( Update Error ); \n         } \n\n     }  }", 
            "title": "Record Events"
        }, 
        {
            "location": "/direct/", 
            "text": "Direct Queries\n\n\nIf you need to perform queries directly, additional fetch\n and yield\n methods\nare provided which expose the Extended PDO functionality. By using the \n$cols\n parameter, you can select specific columns or individual\nvalues. For example:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n?php\n\n\n// an array of IDs\n\n\n$threadIds\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nthread_id\n])\n\n    \n-\nlimit\n(\n10\n)\n\n    \n-\norderBy\n(\nthread_id DESC\n)\n\n    \n-\nfetchCol\n();\n\n\n\n// key-value pairs of IDs and titles\n\n\n$threadIdsAndTitles\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nthread_id\n,\n \ntite\n])\n\n    \n-\nlimit\n(\n10\n)\n\n    \n-\norderBy\n(\nthread_id DESC\n)\n\n    \n-\nfetchPairs\n();\n\n\n\n// etc.\n\n\n\n\n\n\n\nSee \nthe list of \nExtendedPdo::fetch*()\n and \nyield*()\n\nmethods for more.\n\n\nYou can also call \nfetchRow()\n or \nfetchRows()\n to get Row objects directly\nfrom the Table underlying the Mapper.\n\n\nFetching\n\n\nFetch Value\n\n\nReturns a single value, or false.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\n$subject\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n])\n\n    \n-\nwhere\n(\nthread_id = ?\n,\n \n1\n)\n\n    \n-\nfetchValue\n();\n\n\n\n// \nSubject One\n\n\n\n\n\n\n\nFetch Column\n\n\nReturns a sequential array of one column, or an empty array.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$subjects\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n])\n\n    \n-\nlimit\n(\n2\n)\n\n    \n-\nfetchCol\n();\n\n\n\n// [\n\n\n//   0 =\n \nSubject One\n,\n\n\n//   1 =\n \nSubject Two\n\n\n// ]\n\n\n\n\n\n\n\nFetch Pairs\n\n\nReturns an associative array where the key is the first column and the value is\nthe second column, or an empty array.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$subjectAndBody\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n,\n \nbody\n])\n\n    \n-\nlimit\n(\n2\n)\n\n    \n-\nfetchPairs\n();\n\n\n\n// [\n\n\n//   \nSubject One\n =\n \nBody Text One\n,\n\n\n//   \nSubject Two\n =\n \nBody Text Two\n\n\n// ]\n\n\n\n\n\n\n\nFetch One\n\n\nReturns an associative array of one row, or false.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n?php\n\n\n$threadData\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n,\n \nbody\n,\n \nauthor_id\n])\n\n    \n-\nwhere\n(\nthread_id = 1\n)\n\n    \n-\nfetchOne\n();\n\n\n\n// [\n\n\n//   \nsubject\n =\n \nSubject One\n,\n\n\n//   \nbody\n =\n \nBody Text One\n,\n\n\n//   \nauthor_id\n =\n \n1\n\n\n// ]\n\n\n\n\n\n\n\nFetch Assoc\n\n\nReturns an associative array of rows keyed on the first column specified, or an\nempty array.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n?php\n\n\n$threads\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n,\n \nbody\n])\n\n    \n-\nlimit\n(\n2\n)\n\n    \n-\nfetchAssoc\n();\n\n\n\n// [\n\n\n//   \nSubject One\n =\n [\n\n\n//     \nsubject\n =\n \nSubject One\n,\n\n\n//     \nbody\n =\n \nBody Text One\n,\n\n\n//   ],\n\n\n//   \nSubject Two\n =\n [\n\n\n//     \nsubject\n =\n \nSubject Two\n,\n\n\n//     \nbody\n =\n \nBody Text Two\n\n\n//   ]\n\n\n// ]\n\n\n\n\n\n\n\nFetch All\n\n\nReturns a sequential array of associative arrays, or an empty array.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n?php\n\n\n$threads\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n,\n \nbody\n])\n\n    \n-\nlimit\n(\n2\n)\n\n    \n-\norderBy\n(\nthread_id DESC\n)\n\n    \n-\nfetchAll\n();\n\n\n\n// [\n\n\n//   0 =\n [\n\n\n//     \nsubject\n =\n \nSubject One\n,\n\n\n//     \nbody\n =\n \nBody Text One\n\n\n//   ],\n\n\n//   1 =\n [\n\n\n//     \nsubject\n =\n \nSubject Two\n,\n\n\n//     \nbody\n =\n \nBody Text Two\n\n\n//   ]\n\n\n// ]\n\n\n\n\n\n\n\nYielding Data\n\n\nIf you prefer to get the results one at a time, you can use the yield*\nvariations on these methods to iterate through the result set instead of\nreturning an array.\n\n\nYield Col\n\n\nIterate through a sequential array of one column.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$subjects\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n])\n\n    \n-\nyieldCol\n();\n\n\n\nforeach\n(\n$subjects\n \nas\n \n$subject\n)\n \n{\n\n    \necho\n \n$subject\n;\n\n\n}\n\n\n\n\n\n\n\nYield Pairs\n\n\nIterate through an associative array by the first column specified.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$subjectAndBody\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nsubject\n,\n \nbody\n])\n\n    \n-\nyieldPairs\n();\n\n\n\nforeach\n(\n$subjectAndBody\n \nas\n \n$subject\n \n=\n \n$body\n)\n \n{\n\n    \necho\n \n$subject\n \n.\n \n: \n \n.\n \n$body\n;\n\n\n}\n\n\n\n\n\n\n\nYield Assoc\n\n\nIterate through an associative array of rows by the first column specified.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$threads\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nthread_id\n,\n \nsubject\n])\n\n    \n-\nyieldAssoc\n();\n\n\n\nforeach\n(\n$threads\n \nas\n \n$threadId\n \n=\n \n$thread\n)\n \n{\n\n    \necho\n \n$threadId\n \n.\n \n: \n \n.\n \n$thread\n[\nsubject\n];\n\n\n}\n\n\n\n\n\n\n\nYield All\n\n\nIterate through a sequential array of rows.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n$threads\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nthread_id\n,\n \nsubject\n])\n\n    \n-\nyieldAll\n();\n\n\n \nforeach\n(\n$threads\n \nas\n \n$thread\n)\n \n{\n\n    \necho\n \n$thread\n[\nthread_id\n]\n \n.\n \n: \n \n.\n \n$thread\n[\nsubject\n];\n\n\n}\n\n\n\n\n\n\n\nComplex Queries\n\n\nYou can use any of the direct table access methods with more complex queries and\njoins.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n?php\n\n\n$threadData\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\nthreads.subject\n,\n \nauthors.name\n,\n \ns.*\n])\n\n    \n-\njoin\n(\nINNER\n,\n \nauthors\n,\n \nauthors.author_id = threads.author_id\n)\n\n    \n-\njoin\n(\nINNER\n,\n \nsummary s\n,\n \ns.thread_id = threads.thread_id\n)\n\n    \n-\nwhere\n(\nauthors.name = ?\n,\n \n$name\n)\n\n    \n-\norderBy\n(\nthreads.thread_id DESC\n)\n\n    \n-\noffset\n(\n2\n)\n\n    \n-\nlimit\n(\n2\n)\n\n    \n-\nfetchAssoc\n();\n\n\n\n\n\n\n\nReusing the Select\n\n\nThe select object can be used for multiple queries, which may be useful for\npagination.  The generated select statement can also be displayed for debugging\npurposes.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\n$select\n \n=\n \n$atlas\n\n    \n-\nselect\n(\nThreadMapper\n::\nCLASS\n)\n\n    \n-\ncols\n([\n*\n])\n\n    \n-\noffset\n(\n10\n)\n\n    \n-\nlimit\n(\n5\n);\n\n\n\n// Fetch the current result set\n\n\n$results\n \n=\n \n$select\n-\nfetchAll\n();\n\n\n\n// Fetch the row count without any limit or offset\n\n\n$totalCount\n \n=\n \n$select\n-\nfetchCount\n();\n\n\n\n// View the generated select statement\n\n\n$statement\n \n=\n \n$select\n-\ngetStatement\n();", 
            "title": "Direct Queries"
        }, 
        {
            "location": "/direct/#direct-queries", 
            "text": "If you need to perform queries directly, additional fetch  and yield  methods\nare provided which expose the Extended PDO functionality. By using the  $cols  parameter, you can select specific columns or individual\nvalues. For example:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 ?php  // an array of IDs  $threadIds   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ thread_id ]) \n     - limit ( 10 ) \n     - orderBy ( thread_id DESC ) \n     - fetchCol ();  // key-value pairs of IDs and titles  $threadIdsAndTitles   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ thread_id ,   tite ]) \n     - limit ( 10 ) \n     - orderBy ( thread_id DESC ) \n     - fetchPairs ();  // etc.    See  the list of  ExtendedPdo::fetch*()  and  yield*() \nmethods for more.  You can also call  fetchRow()  or  fetchRows()  to get Row objects directly\nfrom the Table underlying the Mapper.", 
            "title": "Direct Queries"
        }, 
        {
            "location": "/direct/#fetching", 
            "text": "", 
            "title": "Fetching"
        }, 
        {
            "location": "/direct/#fetch-value", 
            "text": "Returns a single value, or false.  1\n2\n3\n4\n5\n6\n7\n8 ?php  $subject   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ]) \n     - where ( thread_id = ? ,   1 ) \n     - fetchValue ();  //  Subject One", 
            "title": "Fetch Value"
        }, 
        {
            "location": "/direct/#fetch-column", 
            "text": "Returns a sequential array of one column, or an empty array.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $subjects   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ]) \n     - limit ( 2 ) \n     - fetchCol ();  // [  //   0 =   Subject One ,  //   1 =   Subject Two  // ]", 
            "title": "Fetch Column"
        }, 
        {
            "location": "/direct/#fetch-pairs", 
            "text": "Returns an associative array where the key is the first column and the value is\nthe second column, or an empty array.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $subjectAndBody   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ,   body ]) \n     - limit ( 2 ) \n     - fetchPairs ();  // [  //    Subject One  =   Body Text One ,  //    Subject Two  =   Body Text Two  // ]", 
            "title": "Fetch Pairs"
        }, 
        {
            "location": "/direct/#fetch-one", 
            "text": "Returns an associative array of one row, or false.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 ?php  $threadData   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ,   body ,   author_id ]) \n     - where ( thread_id = 1 ) \n     - fetchOne ();  // [  //    subject  =   Subject One ,  //    body  =   Body Text One ,  //    author_id  =   1  // ]", 
            "title": "Fetch One"
        }, 
        {
            "location": "/direct/#fetch-assoc", 
            "text": "Returns an associative array of rows keyed on the first column specified, or an\nempty array.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 ?php  $threads   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ,   body ]) \n     - limit ( 2 ) \n     - fetchAssoc ();  // [  //    Subject One  =  [  //      subject  =   Subject One ,  //      body  =   Body Text One ,  //   ],  //    Subject Two  =  [  //      subject  =   Subject Two ,  //      body  =   Body Text Two  //   ]  // ]", 
            "title": "Fetch Assoc"
        }, 
        {
            "location": "/direct/#fetch-all", 
            "text": "Returns a sequential array of associative arrays, or an empty array.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 ?php  $threads   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ,   body ]) \n     - limit ( 2 ) \n     - orderBy ( thread_id DESC ) \n     - fetchAll ();  // [  //   0 =  [  //      subject  =   Subject One ,  //      body  =   Body Text One  //   ],  //   1 =  [  //      subject  =   Subject Two ,  //      body  =   Body Text Two  //   ]  // ]", 
            "title": "Fetch All"
        }, 
        {
            "location": "/direct/#yielding-data", 
            "text": "If you prefer to get the results one at a time, you can use the yield*\nvariations on these methods to iterate through the result set instead of\nreturning an array.", 
            "title": "Yielding Data"
        }, 
        {
            "location": "/direct/#yield-col", 
            "text": "Iterate through a sequential array of one column.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $subjects   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ]) \n     - yieldCol ();  foreach ( $subjects   as   $subject )   { \n     echo   $subject ;  }", 
            "title": "Yield Col"
        }, 
        {
            "location": "/direct/#yield-pairs", 
            "text": "Iterate through an associative array by the first column specified.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $subjectAndBody   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ subject ,   body ]) \n     - yieldPairs ();  foreach ( $subjectAndBody   as   $subject   =   $body )   { \n     echo   $subject   .   :    .   $body ;  }", 
            "title": "Yield Pairs"
        }, 
        {
            "location": "/direct/#yield-assoc", 
            "text": "Iterate through an associative array of rows by the first column specified.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $threads   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ thread_id ,   subject ]) \n     - yieldAssoc ();  foreach ( $threads   as   $threadId   =   $thread )   { \n     echo   $threadId   .   :    .   $thread [ subject ];  }", 
            "title": "Yield Assoc"
        }, 
        {
            "location": "/direct/#yield-all", 
            "text": "Iterate through a sequential array of rows.  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  $threads   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ thread_id ,   subject ]) \n     - yieldAll (); \n\n  foreach ( $threads   as   $thread )   { \n     echo   $thread [ thread_id ]   .   :    .   $thread [ subject ];  }", 
            "title": "Yield All"
        }, 
        {
            "location": "/direct/#complex-queries", 
            "text": "You can use any of the direct table access methods with more complex queries and\njoins.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 ?php  $threadData   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ threads.subject ,   authors.name ,   s.* ]) \n     - join ( INNER ,   authors ,   authors.author_id = threads.author_id ) \n     - join ( INNER ,   summary s ,   s.thread_id = threads.thread_id ) \n     - where ( authors.name = ? ,   $name ) \n     - orderBy ( threads.thread_id DESC ) \n     - offset ( 2 ) \n     - limit ( 2 ) \n     - fetchAssoc ();", 
            "title": "Complex Queries"
        }, 
        {
            "location": "/direct/#reusing-the-select", 
            "text": "The select object can be used for multiple queries, which may be useful for\npagination.  The generated select statement can also be displayed for debugging\npurposes.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  $select   =   $atlas \n     - select ( ThreadMapper :: CLASS ) \n     - cols ([ * ]) \n     - offset ( 10 ) \n     - limit ( 5 );  // Fetch the current result set  $results   =   $select - fetchAll ();  // Fetch the row count without any limit or offset  $totalCount   =   $select - fetchCount ();  // View the generated select statement  $statement   =   $select - getStatement ();", 
            "title": "Reusing the Select"
        }
    ]
}