[{"id":"\/mapper\/getting-started.html#1-1-1","title":"1.1.1. Installation","content":"This package is installable and autoloadable via Composer as atlas\/orm. Add the following lines to your composer.json file, then call composer update.{ \"require\": { \"atlas\/orm\": \"~1.0\" }, \"require-dev\": { \"atlas\/cli\": \"~1.0\" } } (The atlas\/cli package provides the atlas-skeleton command-line tool to help create skeleton classes for the mapper.)"},{"id":"\/mapper\/getting-started.html#1-1-2","title":"1.1.2. Creating Data Source Classes","content":"You can create your data source classes by hand, but it's going to be tedious to do so. Instead, use the atlas-skeleton command to read the table information from the database. You can read more about that in the atlas\/cli docs."},{"id":"\/mapper\/getting-started.html#1-1-3","title":"1.1.3. Instantiating Atlas","content":"Create an Atlas instance using the AtlasContainer.The container accepts a PDO, ExtendedPdo or ConnectionLocator instance or you can enter connection parameters and the container creates a connection for you.&lt;?php $atlasContainer = new AtlasContainer(new PDO(...)); \/\/ or $atlasContainer = new AtlasContainer(new ExtendedPdo(...)); \/\/ or $atlasContainer = new AtlasContainer(new ConnectionLocator(...)); \/\/ or $atlasContainer = new AtlasContainer( 'mysql:host=localhost;dbname=testdb', 'username', 'password' ); Next, set the available mapper classes into the container.&lt;?php $atlasContainer-&gt;setMappers([ AuthorMapper::CLASS, ReplyMapper::CLASS, SummaryMapper::CLASS, TagMapper::CLASS, ThreadMapper::CLASS, TaggingMapper::CLASS, ]); Finally, get back the Atlas instance out of the container.&lt;?php $atlas = $atlasContainer-&gt;getAtlas(); "},{"id":"\/mapper\/relationships.html#1-2","title":"1.2. Mapper Relationships","content":"You can add relationships to a mapper inside its setRelated() method, calling one of the four available relationship-definition methods: oneToOne($field, $mapperClass) (aka \"has one\") manyToOne($field, $mapperClass) (aka \"belongs to\") oneToMany($field, $mapperClass) (aka \"has many\") manyToMany($field, $mapperClass, $throughField) (aka \"has many through\") The $field will become a field name on the returned Record object. That field will be populated from the specified $mapperClass in Atlas. (In the case of manyToMany(), the association mappings will come from the specified $throughField.)Here is an example:&lt;?php namespace App\\DataSource\\Thread; use App\\DataSource\\Author\\AuthorMapper; use App\\DataSource\\Summary\\SummaryMapper; use App\\DataSource\\Reply\\ReplyMapper; use App\\DataSource\\Tagging\\TaggingMapper; use App\\DataSource\\Tag\\TagMapper; use Atlas\\Orm\\Mapper\\AbstractMapper; class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;manyToOne('author', AuthorMapper::CLASS); $this-&gt;oneToOne('summary', SummaryMapper::CLASS); $this-&gt;oneToMany('replies', ReplyMapper::CLASS); $this-&gt;oneToMany('taggings', TaggingMapper::CLASS); $this-&gt;manyToMany('tags', TagMapper::CLASS, 'taggings'); } } "},{"id":"\/mapper\/relationships.html#1-2-1","title":"1.2.1. Relationship Key Columns","content":"By default, in all relationships except many-to-one, the relationship will take the primary key column(s) in the native table, and map to those same column names in the foreign table.In the case of many-to-one, it is the reverse; that is, the relationship will take the primary key column(s) in the foreign table, and map to those same column names in the native table.If you want to use different columns, call the on() method on the relationship. For example, if the threads table uses author_id, but the authors table uses just id, you can do this:&lt;?php class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;manyToOne('author', AuthorMapper::CLASS) -&gt;on([ \/\/ native (threads) column =&gt; foreign (authors) column 'author_id' =&gt; 'id', ]); \/\/ ... } } And on the oneToMany side of the relationship, you use the native author table id column with the foreign threads table author_id column.&lt;?php class AuthorMapper extends AbstractMapper { protected function setRelated() { $this-&gt;oneToMany('posts', PostsMapper::CLASS) -&gt;on([ \/\/ native (author) column =&gt; foreign (threads) column 'id' =&gt; 'author_id', ]); \/\/ ... } } "},{"id":"\/mapper\/relationships.html#1-2-2","title":"1.2.2. Composite Relationship Keys","content":"Likewise, if a table uses a composite key, you can re-map the relationship on multiple columns. If table foo has composite primary key columns of acol and bcol, and it maps to table bar on foo_acol and foo_bcol, you would do this:&lt;?php class FooMapper { protected function setRelated() { $this-&gt;oneToMany('bars', BarMapper::CLASS) -&gt;on([ \/\/ native (foo) column =&gt; foreign (bar) column 'acol' =&gt; 'foo_acol', 'bcol' =&gt; 'foo_bcol', ]); } } "},{"id":"\/mapper\/relationships.html#1-2-3","title":"1.2.3. Case-Sensitivity","content":" Note: This applies only to string-based relationship keys. If you are using numeric relationship keys, this section does not apply. Atlas will match records related by string keys in a case-senstive manner. If your collations on the related string key columns are not case sensitive, Atlas might not match up related records properly in memory after fetching them from the database. This is because 'foo' and 'FOO' might be equivalent in the database collation, but they are not equivalent in PHP.In that kind of situation, you will want to tell the relationship to ignore the case of related string key columns when matching related records. You can do so with the ignoreCase() method on the relationship definition. &lt;?php class FooMapper { protected function setRelated() { $this-&gt;oneToMany('bars', BarMapper::CLASS) -&gt;ignoreCase(); } } With that in place, a native value of 'foo' match to a foreign value of 'FOO' when Atlas is stitching together related records."},{"id":"\/mapper\/relationships.html#1-2-4","title":"1.2.4. Simple WHERE Conditions","content":"You may find it useful to define simple WHERE conditions on the foreign side of the relationship. For example, you can handle one side of a so-called polymorphic relationship by selecting only related records of a particular type.In the following example, a comments table has a commentable_id column as the foreign key value, but is restricted to \"issue\" values on a discriminator column named commentable.class IssueMapper extends AbstractMapper { protected function setRelated() { $this-&gt;oneToMany('comments', CommentMapper::CLASS) -&gt;on([ 'issue_id' =&gt; 'commentable_id' ]) -&gt;where('commentable = ?', 'issue'); } } (These conditions will be honored by MapperSelect::*joinWith() as well.)"},{"id":"\/mapper\/reading.html#1-3","title":"1.3. Fetching Records and RecordSets","content":"Use Atlas to retrieve a single Record, or many Records in a RecordSet, from the database."},{"id":"\/mapper\/reading.html#1-3-1","title":"1.3.1. Fetching a Record","content":"Use the fetchRecord() method to retrieve a single Record. It can be called either by primary key, or with a select() query.&lt;?php \/\/ fetch by primary key thread_id = 1 $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::class, '1' ); $threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', '1') -&gt;fetchRecord();  Tip: The select() variation gives you access to all the underlying SQL query methods. See Aura\\SqlQuery for more information.  Note: If fetchRecord() does not find a match, it will return false.  Warning: If using the select() variation with the cols() method, be sure to include the table's primary key column(s) if you are fetching a Record. If using one of the other fetch*() methods outlined in the chapter on Direct Queries, then this isn't necessary. See below. &lt;?php \/\/ must include the primary key column (and author_id because of the \/\/ where clause) $threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('author_id = ?', '2') -&gt;cols(['thread_id', 'title', 'author_id']) -&gt;fetchRecord(); \/\/ No need to include the primary key column $threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('author_id = ?', '2') -&gt;cols(['title', 'author_id']) -&gt;fetchOne(); "},{"id":"\/mapper\/reading.html#1-3-1-1","title":"1.3.1.1. Accessing\/Reading Record Data","content":"Once you have a Record, you can access the columns via properties on the Record. Assume a database column called title.&lt;?php echo $thread-&gt;title; "},{"id":"\/mapper\/reading.html#1-3-2","title":"1.3.2. Fetching A RecordSet","content":"The fetchRecordSet() method works the same as fetchRecord(), but for multiple Records. It can be called either with primary keys, or with a select() query.&lt;?php \/\/ fetch thread_id 1, 2, and 3 $threadRecordSet = $atlas-&gt;fetchRecordSet( ThreadMapper::CLASS, [1, 2, 3] ); \/\/ This is identical to the example above, but uses the `select()` variation. $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;where('thread_id IN (?)', [1, 2, 3]) -&gt;fetchRecordSet(); To return all rows, use the select() variation as shown below.&lt;?php \/\/ Use the `select()` variation to fetch all records, optionally ordering the \/\/ returned results $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;orderBy(['date_added DESC']) -&gt;fetchRecordSet();  Tip: The select() variation gives you access to all the underlying SQL query methods. See Aura\\SqlQuery for more information.  Note: If fetchRecordSet() does not find any matches, it will return an empty array. This is important as you cannot call RecordSet methods (see later in the documentation) such as appendNew() or getArrayCopy() on an empty array. In these situations, you must test for the empty array, and then instantiate a new RecordSet, if necessary. See below. &lt;?php $threadRecordSet = $atlas-&gt;fetchRecordSet( ThreadMapper::CLASS, [1, 2, 3] ); if (! $threadRecordSet) { $threadRecordSet = $atlas-&gt;newRecordSet(ThreadMapper::CLASS); } $threadMapper-&gt;appendNew(...); "},{"id":"\/mapper\/reading.html#1-3-2-1","title":"1.3.2.1. Accessing\/Reading RecordSet Data","content":"RecordSets act as arrays of Records. As such, you can easily iterate over the RecordSet and access the Records individually.&lt;?php \/\/ fetch the top 100 threads $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;orderBy(['thread_id DESC']) -&gt;limit(100) -&gt;fetchRecordSet(); foreach ($threadRecordSet as $threadRecord) { echo $threadRecord-&gt;title; } "},{"id":"\/mapper\/reading.html#1-3-3","title":"1.3.3. Fetching Related Records","content":"Any relationships that are set in the Mapper will appear as NULL in the Record object. Related data will only be populated if it is explicitly requested as part of the fetch or select.On a fetch*(), load relateds using a third argument: an array specifying which related fields to retrieve.&lt;?php $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, '1', [ 'author', 'summary', 'replies', ] ); $threadRecordSet = $atlas-&gt;fetchRecordSet( ThreadMapper::CLASS, [1, 2, 3], [ 'author', 'summary', 'replies', ] ); When using the select() variation, load relateds using the with() method:&lt;?php $threadRecord = $atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', '1') -&gt;with([ 'author', 'summary', 'replies', ]) -&gt;fetchRecord(); $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;where('thread_id IN (?)', [1, 2, 3]) -&gt;with([ 'author', 'summary', 'replies', ]) -&gt;fetchRecordSet();  Note: When fetching a manyToMany relationship, you must explicitly specify both the association (through) related AND the manyToMany related. Additionally, you must specify these relationships in the correct order. &lt;?php $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, '1', [ 'taggings', \/\/ specify the through first 'tags' \/\/ then the manyToMany ] ); Relationships can be nested as deeply as needed. For example, to fetch the author of each reply on each thread:&lt;?php $threadRecord = $this-&gt;atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', $threadId) -&gt;with([ 'author', 'summary', 'replies' =&gt; [ 'author' ] ]) -&gt;fetchRecord(); Alternatively, you can pass a closure to exercise fine control over the query that fetches the relateds:&lt;?php \/\/ fetch thread_id 1; with only the last 10 related replies in descending order; \/\/ including each reply author $threadRecord = $atlas-&gt;fetchRecord( ThreadMapper::CLASS, '1', [ 'author', 'summary', 'replies' =&gt; function ($selectReplies) { $selectReplies -&gt;limit(10) -&gt;orderBy(['reply_id DESC']) -&gt;with([ 'author' ]); }, ] ); "},{"id":"\/mapper\/reading.html#1-3-3-1","title":"1.3.3.1. Accessing\/Reading Related Data","content":"Accessing related data works just like accessing Record properties except instead of using a column name, you use the relationship name defined in the mapper.&lt;?php $threadRecord = $this-&gt;atlas -&gt;select(ThreadMapper::class) -&gt;where('thread_id = ?', $threadId) -&gt;with([ 'author', 'summary', 'replies' =&gt; [ 'author' ] ]) -&gt;fetchRecord(); \/\/ Assume the author table has a column named `last_name` foreach ($threadRecord-&gt;replies as $reply) { echo $reply-&gt;author-&gt;last_name; } "},{"id":"\/mapper\/reading.html#1-3-4","title":"1.3.4. Returning Data in Other Formats","content":"You can return a Record or a RecordSet as an array rather than a Record or RecordSet object using the getArrayCopy() method.&lt;?php $threadRecord = $atlas-&gt;fetchRecord('ThreadMapper::CLASS', '1'); $threadArray = $threadRecord-&gt;getArrayCopy(); $threadRecordSet = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;orderBy(['date_added DESC']) -&gt;fetchRecordSet(); $threadsArray = $threadRecordSet-&gt;getArrayCopy(); JSON-encoding Records and RecordSets is trival.&lt;?php $threadJson = json_encode($threadRecord); $threadsJson = json_encode($threadRecordSet); "},{"id":"\/mapper\/reading.html#1-3-5","title":"1.3.5. Reading Record Counts","content":"If you use a select() to fetch a RecordSet with a limit() or page(), you can re-use the select to get a count of how many Records would have been returned. This can be useful for paging displays.&lt;?php $select = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;with([ 'author', 'summary', 'replies' ]) -&gt;limit(10) -&gt;offset(20); $threadRecordSet = $select-&gt;fetchRecordSet(); $countOfAllThreads = $select-&gt;fetchCount(); "},{"id":"\/mapper\/records.html#1-4-1","title":"1.4.1. Creating and Inserting a Record","content":"Create a new Record using the newRecord() method. You can assign data using properties, or pass an array of initial data to populate into the Record.&lt;?php $thread = $atlas-&gt;newRecord(ThreadMapper::CLASS, [ 'title'=&gt;'New Thread Title', ] ); You can assign a value via a property, which maps to a column name.&lt;?php $date = new \\DateTime(); $thread-&gt;date_added = $date-&gt;format('Y-m-d H:i:s'); You can insert a single Record back to the database by using the Atlas::insert() method. This will use the appropriate Mapper for the Record to perform the write within a transaction, and capture any exceptions that occur along the way.&lt;?php $success = $atlas-&gt;insert($thread); if ($success) { echo \"Wrote the Record back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } Inserting a Record with an auto-incrementing primary key will automatically modify the Record to set the last-inserted ID.Inserting a Record will automatically set the foreign key fields on the native Record, and on all the loaded relationships for that Record.In the following example, assume a Thread Record has a manyToOne relationship with an Author Record using the author_id column. The relationship is named author. (See the section on relationships for more information.)&lt;?php $author = $atlas-&gt;fetchRecord(AuthorMapper::CLASS, 4); $thread = $atlas-&gt;newRecord(ThreadMapper::CLASS, [ 'title'=&gt;'New Thread Title', 'author'=&gt;$author ] ); \/\/ If the insert is successful, the `author_id` column will automatically be \/\/ set to the Author Record's primary key value. In this case, 4. $success = $atlas-&gt;insert($thread); echo $thread-&gt;author_id; \/\/ 4  Note: If the Author Record is new, Atlas will NOT automatically insert the new Author and set the foreign key on the new Author Record via the insert() method. This can, however, be achieved using the persist() method. This is discussed later in this chapter. The following will fail.&lt;?php $author = $atlas-&gt;newRecord(AuthorMapper::CLASS, [ 'first_name'=&gt;'Sterling', 'last_name'=&gt;'Archer' ] ); $thread = $atlas-&gt;newRecord(ThreadMapper::CLASS, [ 'title'=&gt;'New Thread Title', 'author'=&gt;$author ] ); \/\/ Insert will not create the related Author Record. Use persist() instead. $success = $atlas-&gt;insert($thread); "},{"id":"\/mapper\/records.html#1-4-2","title":"1.4.2. Updating an Existing Record","content":"Updating an existing record works the same as insert().&lt;?php \/\/ fetch an existing record by primary key $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 3); \/\/ Modify the title $thread-&gt;title = 'This title is better than the last one'; \/\/ Save the record back to the database. $success = $atlas-&gt;update($thread); if ($success) { echo \"Wrote the Record back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } As with insert(), foreign keys are also updated, but only for existing related records.&lt;?php $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 3); $author = $atlas-&gt;fetchRecord(AuthorMapper::CLASS, 4); \/\/ Modify the author $thread-&gt;author = $author; \/\/ Save the record back to the database. $success = $atlas-&gt;update($thread); if ($success) { echo \"Wrote the Record back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } "},{"id":"\/mapper\/records.html#1-4-3","title":"1.4.3. Deleting a Record","content":"Deleting a record works the same as inserting or updating.&lt;?php $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 3); $success = $atlas-&gt;delete($thread); if ($success) { echo \"Removed record from the database.\"; } else { echo \"Did not remove the Record: \" . $atlas-&gt;getException(); } "},{"id":"\/mapper\/records.html#1-4-4","title":"1.4.4. Persisting a Record","content":"If you like, you can persist a Record and all of its loaded relationships (and all of their loaded relationships, etc.) back to the database using the Atlas persist() method. This is good for straightforward relationship structures where the order of write operations does not need to be closely managed.The persist() method will: persist many-to-one and many-to-many relateds loaded on the native Record; persist the native Record by ... inserting the Row for the Record if it is new; or, updating the Row for the Record if it has been modified; or, deleting the Row for the Record if the Record has been marked for deletion using the Record::markForDeletion() method; persist one-to-one and one-to-many relateds loaded on the native Record. &lt;?php $success = $atlas-&gt;persist($record); if ($success) { echo \"Wrote the Record and all of its relateds back to the database.\"; } else { echo \"Did not write the Record: \" . $atlas-&gt;getException(); } As with insert and update, this will automatically set the foreign key fields on the native Record, and on all the loaded relationships for that Record.If a related field is not loaded, it cannot be persisted automatically.Note that whether or not the Row for the Record is inserted\/updated\/deleted, the persist() method will still recursively traverse all the related fields and persist them as well.The delete() method will not attempt to cascade deletion or nullification across relateds at the ORM level. Your database may have cascading set up at the database level; Atlas has no control over this."},{"id":"\/mapper\/records.html#1-4-5","title":"1.4.5. Marking Records for Deletion","content":"You may also mark records for deletion and they will be removed from the database after a transaction is completed via persist().&lt;?php $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 3); \/\/ Mark the record for deletion $thread-&gt;markForDeletion(); $atlas-&gt;persist($thread); You can also mark several related Records for deletion and when the native Record is persisted, they will be deleted from the database.&lt;?php \/\/ Assume a oneToMany relationship between a thread and its comments \/\/ Select the thread and related comments $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 3, [ 'comments' ] ); \/\/ Mark each related comment for deletion foreach ($thread-&gt;comments as $comment) { $comment-&gt;markForDeletion(); } \/\/ Persist the thread and the comments are also deleted $atlas-&gt;persist($thread); "},{"id":"\/mapper\/record-sets.html#1-5-1","title":"1.5.1. New RecordSets","content":"Create a new RecordSet using the newRecordSet() method.&lt;?php $threadRecordSet = $atlas-&gt;newRecordSet(ThreadMapper::CLASS); "},{"id":"\/mapper\/record-sets.html#1-5-2","title":"1.5.2. Appending Records to a RecordSet","content":"You can append a new Record to an existing RecordSet using appendNew(), optionally passing any data you want to initially populate into the Record:&lt;?php $newThread = $threadRecordSet-&gt;appendNew([ 'title' =&gt; 'New Title', ]); Additionally, you can append foreign Records to a native Record's relateds.&lt;?php $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, 1, [ 'comments', ] ); \/\/ Ensure we have a RecordSet to append to if (! $thread-&gt;comments) { $thread-&gt;comments = $atlas-&gt;newRecordSet(CommentMapper::CLASS); } $comment = $thread-&gt;comments-&gt;appendNew([ 'thread_id' =&gt; $thread-&gt;thread_id, 'comment' =&gt; 'Lorem ipsum dolor sit amet...' ]); \/\/ plan to insert the new comment $transaction-&gt;insert($comment); \/\/ Or persist the thread $atlas-&gt;persist($thread); "},{"id":"\/mapper\/record-sets.html#1-5-3","title":"1.5.3. Array Access","content":"The RecordSet also acts as an array, so you can get\/set\/unset Records by their sequential keys in the RecordSet.&lt;?php \/\/ address the second record in the set $threadRecordSet[1]-&gt;title = 'Changed Title'; \/\/ unset the first record in the set unset($threadRecordSet[0]); \/\/ push a new record onto the set $threadRecordSet[] = $atlas-&gt;newRecord(ThreadMapper::CLASS); "},{"id":"\/mapper\/record-sets.html#1-5-4","title":"1.5.4. Searching within RecordSets","content":"You can search for Records within an existing RecordSet by their column values:&lt;?php $threadRecordSet = $atlas-&gt;select(ThreadMapper::CLASS) -&gt;where('published=?', 1) -&gt;fetchRecordSet(); \/\/ returns one matching Record object from the RecordSet, \/\/ or false if there is no match $matchingRecord = $threadRecordSet-&gt;getOneBy(['subject' =&gt; 'Subject One']); \/\/ returns an array of matching Record objects from the RecordSet $matchingRecords = $threadRecordSet-&gt;getAllBy(['author_id' =&gt; '5']); "},{"id":"\/mapper\/record-sets.html#1-5-5","title":"1.5.5. Removing Records from RecordSets","content":"You can remove Records from a RecordSet by their column values. This does NOT delete the Record from the database; only from the RecordSet.&lt;?php \/\/ unsets and returns one matching Record from the Record Set, \/\/ or false if there is no match $removedRecord = $threadRecordSet-&gt;removeOneBy(['subject' =&gt; 'Subject One']); \/\/ unsets and returns an array of matching Record objects from the Record Set $removedRecords = $threadRecordSet-&gt;removeAllBy(['author_id' =&gt; '5']);  Note: This only removes them from the RecordSet; it does not delete them from the database. If you need to delete a record from the database, see the sections on Marking Records for Deletion and deleting Records. "},{"id":"\/mapper\/transactions.html#1-6","title":"1.6. Transactions (Unit of Work)","content":"If you make changes to several Records, you can write them back to the database using a unit-of-work Transaction. You can plan for Records to be inserted, updated, and deleted, in whatever order you like, and then execute the entire transaction plan at once. Exceptions will cause a rollback.&lt;?php \/\/ create a transaction $transaction = $atlas-&gt;newTransaction(); \/\/ plan work for the transaction $transaction-&gt;insert($record1); $transaction-&gt;update($record2); $transaction-&gt;delete($record3); \/\/ or persist an entire record and its relateds $transaction-&gt;persist($record4); \/\/ execute the transaction plan $success = $transaction-&gt;exec(); if ($success) { echo \"The Transaction succeeded!\"; } else { \/\/ get the exception that was thrown in the transaction $e = $transaction-&gt;getException(); \/\/ get the work element that threw the exception $work = $transaction-&gt;getFailure(); \/\/ some output echo \"The Transaction failed: \"; echo $work-&gt;getLabel() . ' threw ' . $e-&gt;getMessage(); } "},{"id":"\/mapper\/logic.html#1-7","title":"1.7. Record and RecordSet Logic","content":"Atlas makes it easy to add your own logic to both Records and RecordSets. To accomplish this, you need a Record class for custom Record logic, and a RecordSet class for custom RecordSet logic. The Atlas CLI script (installable via composer using atlas\/cli), can create these classes for you, saving you from manually writing them.Consult the Atlas CLI documentation.It's important to note that the Record and RecordSet objects described below should only be used for very simple behaviours. Any non-trivial domain work may be an indication that you need a domain layer. See the documentation on Domain Models for examples of how you can use Atlas to build a domain layer.Here is an example using the atlas\/cli package and the --full option..\/vendor\/bin\/atlas-skeleton.php \\ --conn=\/path\/to\/conn.php \\ --dir=src\/App\/DataSource \\ --table=threads \\ --full \\ App\\\\DataSource\\\\Thread Upon completion, you will have a folder layout as follows:-- src -- App -- DataSource -- Thread -- ThreadMapper.php -- ThreadMapperEvents.php -- ThreadRecord.php -- ThreadRecordSet.php -- ThreadTable.php -- ThreadTableEvents.php Once you have a Record Class (ThreadRecord.php), you can create custom methods to call from your Record object.&lt;?php namespace App\\DataSource\\Thread; use Atlas\\Orm\\Mapper\\Record; \/** * @inheritdoc *\/ class ThreadRecord extends Record { \/\/ Format the date_created property public function formatDate($format = 'M jS, Y') { $dateTime = new \\DateTime($this-&gt;date_created); return $dateTime-&gt;format($format); } } $thread = $atlas-&gt;fetchRecord(ThreadMapper::CLASS, $id); echo $thread-&gt;formatDate(); \/\/ outputs something like `Aug 21st, 2017` The same concept is available for RecordSets using the RecordSet class. In our example ThreadRecordSet.php.&lt;?php namespace App\\DataSource\\Thread; use Atlas\\Orm\\Mapper\\RecordSet; \/** * @inheritdoc *\/ class ThreadRecordSet extends RecordSet { public function foo() { $data = [] foreach ($this as $record) { $data[] = $record-&gt;title; } return implode('; ', $data); } } $threads = $atlas-&gt;fetchRecordSet(ThreadMapper::CLASS, [1, 2, 3]); echo $threads-&gt;foo(); "},{"id":"\/mapper\/events.html#1-8-1","title":"1.8.1. Record Events","content":"There are several events that will automatically be called when interacting with a Record object. If you used the Atlas CLI tool with the --full option, a MapperEvents class will be created for you. For example, ThreadMapperEvents.php. With this class, you can override any of the available mapper events."},{"id":"\/mapper\/events.html#1-8-1-1","title":"1.8.1.1. Available Events","content":"The insert(), update(), and delete() methods all have 3 events associated with them. A before*(), a modify*(), and an after*().&lt;?php \/\/ Runs before the Insert object is created beforeInsert(MapperInterface $mapper, RecordInterface $record) \/\/ Runs after the Insert object is created, but before it is executed modifyInsert(MapperInterface $mapper, RecordInterface $record, Insert $insert) \/\/ Runs after the Insert object is executed afterInsert(MapperInterface $mapper, RecordInterface $record, Insert $insert, PDOStatement $pdoStatement) \/\/ Runs before the Update object is created beforeUpdate(MapperInterface $mapper, RecordInterface $record) \/\/ Runs after the Update object is created, but before it is executed modifyUpdate(MapperInterface $mapper, RecordInterface $record, Update $update) \/\/ Runs after the Update object is executed afterUpdate(MapperInterface $mapper, RecordInterface $record, Update $update, PDOStatement $pdoStatement) \/\/ Runs before the Delete object is created beforeDelete(MapperInterface $mapper, RecordInterface $record) \/\/ Runs after the Delete object is created, but before it is executed modifyDelete(MapperInterface $mapper, RecordInterface $record, Delete $delete) \/\/ Runs after the Delete object is executed afterDelete(MapperInterface $mapper, RecordInterface $record, Delete $delete, PDOStatement $pdoStatement) Here is a simple example with the assumption that the Record object has a validate() method and a getErrors() method. See the section on Adding Logic to Records and RecordSets.&lt;?php namespace Blog\\DataSource\\Posts; use Atlas\\Orm\\Mapper\\MapperEvents; use Atlas\\Orm\\Mapper\\MapperInterface; use Atlas\\Orm\\Mapper\\RecordInterface; use Atlas\\Orm\\Exception; \/** * @inheritdoc *\/ class PostsMapperEvents extends MapperEvents { public function beforeUpdate(MapperInterface $mapper, RecordInterface $record) { if (! $record-&gt;validate()) throw new Exception('Update Error'); } } } And you might have something like this in your code:&lt;?php $success = $atlas-&gt;update($post); if ($sucess) { echo \"Post updated\"; } else { foreach ($post-&gt;getErrors as $error) { echo $error . '&lt;br\/&gt;'; } } "},{"id":"\/mapper\/direct.html#1-9","title":"1.9. Direct Queries","content":"If you need to perform queries directly, additional fetch* and yield* methods are provided which expose the Extended PDO functionality. By using the $cols parameter, you can select specific columns or individual values. For example:&lt;?php \/\/ an array of IDs $threadIds = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id']) -&gt;limit(10) -&gt;orderBy('thread_id DESC') -&gt;fetchCol(); \/\/ key-value pairs of IDs and titles $threadIdsAndTitles = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'tite']) -&gt;limit(10) -&gt;orderBy('thread_id DESC') -&gt;fetchPairs(); \/\/ etc. See the list of ExtendedPdo::fetch*() and yield*() methods for more.You can also call fetchRow() or fetchRows() to get Row objects directly from the Table underlying the Mapper."},{"id":"\/mapper\/direct.html#1-9-1-1","title":"1.9.1.1. Fetch Value","content":"Returns a single value, or false.&lt;?php $subject = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;where('thread_id = ?', '1') -&gt;fetchValue(); \/\/ \"Subject One\" "},{"id":"\/mapper\/direct.html#1-9-1-2","title":"1.9.1.2. Fetch Column","content":"Returns a sequential array of one column, or an empty array.&lt;?php $subjects = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;limit(2) -&gt;fetchCol(); \/\/ [ \/\/ 0 =&gt; \"Subject One\", \/\/ 1 =&gt; \"Subject Two\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-9-1-3","title":"1.9.1.3. Fetch Pairs","content":"Returns an associative array where the key is the first column and the value is the second column, or an empty array.&lt;?php $subjectAndBody = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;fetchPairs(); \/\/ [ \/\/ 'Subject One' =&gt; \"Body Text One\", \/\/ 'Subject Two' =&gt; \"Body Text Two\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-9-1-4","title":"1.9.1.4. Fetch One","content":"Returns an associative array of one row, or false.&lt;?php $threadData = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body', 'author_id']) -&gt;where('thread_id = 1') -&gt;fetchOne(); \/\/ [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\", \/\/ 'author_id' =&gt; \"1\" \/\/ ] "},{"id":"\/mapper\/direct.html#1-9-1-5","title":"1.9.1.5. Fetch Assoc","content":"Returns an associative array of rows keyed on the first column specified, or an empty array.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;fetchAssoc(); \/\/ [ \/\/ 'Subject One' =&gt; [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\", \/\/ ], \/\/ 'Subject Two' =&gt; [ \/\/ 'subject' =&gt; \"Subject Two\", \/\/ 'body' =&gt; \"Body Text Two\" \/\/ ] \/\/ ] "},{"id":"\/mapper\/direct.html#1-9-1-6","title":"1.9.1.6. Fetch All","content":"Returns a sequential array of associative arrays, or an empty array.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;limit(2) -&gt;orderBy('thread_id DESC') -&gt;fetchAll(); \/\/ [ \/\/ 0 =&gt; [ \/\/ 'subject' =&gt; \"Subject One\", \/\/ 'body' =&gt; \"Body Text One\" \/\/ ], \/\/ 1 =&gt; [ \/\/ 'subject' =&gt; \"Subject Two\", \/\/ 'body' =&gt; \"Body Text Two\" \/\/ ] \/\/ ] "},{"id":"\/mapper\/direct.html#1-9-2","title":"1.9.2. Yielding Data","content":"If you prefer to get the results one at a time, you can use the yield* variations on these methods to iterate through the result set instead of returning an array."},{"id":"\/mapper\/direct.html#1-9-2-1","title":"1.9.2.1. Yield Col","content":"Iterate through a sequential array of one column.&lt;?php $subjects = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject']) -&gt;yieldCol(); foreach($subjects as $subject) { echo $subject; } "},{"id":"\/mapper\/direct.html#1-9-2-2","title":"1.9.2.2. Yield Pairs","content":"Iterate through an associative array by the first column specified.&lt;?php $subjectAndBody = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['subject', 'body']) -&gt;yieldPairs(); foreach($subjectAndBody as $subject =&gt; $body) { echo $subject . \": \" . $body; } "},{"id":"\/mapper\/direct.html#1-9-2-3","title":"1.9.2.3. Yield Assoc","content":"Iterate through an associative array of rows by the first column specified.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'subject']) -&gt;yieldAssoc(); foreach($threads as $threadId =&gt; $thread) { echo $threadId . \": \" . $thread['subject']; } "},{"id":"\/mapper\/direct.html#1-9-2-4","title":"1.9.2.4. Yield All","content":"Iterate through a sequential array of rows.&lt;?php $threads = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['thread_id', 'subject']) -&gt;yieldAll(); foreach($threads as $thread) { echo $thread['thread_id'] . \": \" . $thread['subject']; } "},{"id":"\/mapper\/direct.html#1-9-3","title":"1.9.3. Complex Queries","content":"You can use any of the direct table access methods with more complex queries and joins.&lt;?php $threadData = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['threads.subject', 'authors.name', 's.*']) -&gt;join('INNER', 'authors', 'authors.author_id = threads.author_id') -&gt;join('INNER', 'summary s', 's.thread_id = threads.thread_id') -&gt;where('authors.name = ?', $name) -&gt;orderBy('threads.thread_id DESC') -&gt;offset(2) -&gt;limit(2) -&gt;fetchAssoc(); "},{"id":"\/mapper\/direct.html#1-9-4","title":"1.9.4. Reusing the Select","content":"The select object can be used for multiple queries, which may be useful for pagination. The generated select statement can also be displayed for debugging purposes.&lt;?php $select = $atlas -&gt;select(ThreadMapper::CLASS) -&gt;cols(['*']) -&gt;offset(10) -&gt;limit(5); \/\/ Fetch the current result set $results = $select-&gt;fetchAll(); \/\/ Fetch the row count without any limit or offset $totalCount = $select-&gt;fetchCount(); \/\/ View the generated select statement $statement = $select-&gt;getStatement(); "},{"id":"\/mapper\/domain.html#1-10","title":"1.10. Domain Models","content":"You can go a long way with just your persistence model Records. However, at some point you may want to separate your persistence model Records from your domain model Entities and Aggregates. This section offers some suggestions and examples on how to do that."},{"id":"\/mapper\/domain.html#1-10-1","title":"1.10.1. Persistence Model","content":"For the examples below, we will work with an imaginary forum application that has conversation threads. The ThreadMapper might something like this:&lt;?php namespace App\\DataSource\\Thread; use App\\DataSource\\Author\\AuthorMapper; use App\\DataSource\\Summary\\SummaryMapper; use App\\DataSource\\Reply\\ReplyMapper; use App\\DataSource\\Tagging\\TaggingMapper; use App\\DataSource\\Tag\\TagMapper; use Atlas\\Orm\\Mapper\\AbstractMapper; class ThreadMapper extends AbstractMapper { protected function setRelated() { $this-&gt;manyToOne('author', AuthorMapper::CLASS); $this-&gt;oneToOne('summary', SummaryMapper::CLASS); $this-&gt;oneToMany('replies', ReplyMapper::CLASS); $this-&gt;oneToMany('taggings', TaggingMapper::CLASS); $this-&gt;manyToMany('tags', TagMapper::CLASS, 'taggings'); } } (We will leave the other mappers and their record classes for the imagination.)"},{"id":"\/mapper\/domain.html#1-10-2","title":"1.10.2. Domain Model Interfaces","content":"At some point, we have decided we want to depend on domain Entities or Aggregates, rather than persistence Records, in our application.For example, the interface we want to use for a Thread Entity in domain might look like this:&lt;?php namespace App\\Domain\\Thread; interface ThreadInterface { public function getId(); public function getSubject(); public function getBody(); public function getDatePublished(); public function getAuthorId(); public function getAuthorName(); public function getTags(); public function getReplies(); } (This interface allows us to typehint the application against these domain- specific Entity methods, rather than using the persistence Record properties.)Further, we will presume a naive domain repository implementation that returns Thread Entities. It might look something like this:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadMapper; class ThreadRepository { protected $mapper; public function __construct(ThreadMapper $mapper) { $this-&gt;mapper = $mapper; } public function fetchThread($thread_id) { $record = $this-&gt;mapper-&gt;fetchRecord($thread_id, [ 'author', 'taggings', 'tags', 'replies', ]); return $this-&gt;newThread($record); } protected function newThread(ThreadRecord $record) { \/* ??? *\/ } } The problem now is the newThread() factory method. How do we convert a persistence layer ThreadRecord into a domain layer ThreadInterface implementation?There are three options, each with different tradeoffs: Implement the domain interface in the persistence layer. Compose the persistence record into the domain object. Map the persistence record fields to domain implementation fields. "},{"id":"\/mapper\/domain.html#1-10-3","title":"1.10.3. Implement Domain In Persistence","content":"The easiest thing to do is to implement the domain ThreadInterface in the persistence ThreadRecord, like so:&lt;?php namespace App\\DataSource\\Thread; use Atlas\\Orm\\Mapper\\Record; use App\\Domain\\Thread\\ThreadInterface; class ThreadRecord extends Record implements ThreadInterface { public function getId() { return $this-&gt;thread_id; } public function getTitle() { return $this-&gt;title; } public function getBody() { return $this-&gt;body; } public function getDatePublished() { return $this-&gt;date_published; } public function getAuthorId() { return $this-&gt;author-&gt;author_id; } public function getAuthorName() { return $this-&gt;author-&gt;name; } public function getTags() { return $this-&gt;tags-&gt;getArrayCopy(); } public function getReplies() { return $this-&gt;replies-&gt;getArrayCopy(); } } With this, the ThreadRepository::newThread() factory method doesn't actually need to factory anything at all. It just returns the persistence record, since the record now has the domain interface.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return $record; } Pros: Trivial to implement. Cons: Exposes the persistence layer Record methods and properties to the domain layer, where they can be easily abused. "},{"id":"\/mapper\/domain.html#1-10-4","title":"1.10.4. Compose Persistence Into Domain","content":"Almost as easy, but with better separation, is to have a domain layer object that implements the domain interface, but encapsulates the persistence record as the data source. The domain object might look something like this:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadRecord; class Thread implements ThreadInterface { protected $record; public function __construct(ThreadRecord $record) { $this-&gt;record = $record; } public function getId() { return $this-&gt;record-&gt;thread_id; } public function getTitle() { return $this-&gt;record-&gt;title; } public function getBody() { return $this-&gt;record-&gt;body; } public function getDatePublished() { return $this-&gt;record-&gt;date_published; } public function getAuthorId() { return $this-&gt;record-&gt;author-&gt;author_id; } public function getAuthorName() { return $this-&gt;record-&gt;author-&gt;name; } public function getTags() { return $this-&gt;record-&gt;tags-&gt;getArrayCopy(); } public function getReplies() { return $this-&gt;record-&gt;replies-&gt;getArrayCopy(); } } Now the ThreadRepository::newThread() factory method has to do a little work, but not much. All it needs is to create the Thread domain object with the ThreadRecord as a constructor dependency.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return new Thread($record); } Pros: Hides the persistence record behind the domain interface. Easy to implement. Cons: The domain object is now dependent on the persistence layer, which is not the direction of dependencies we'd prefer. "},{"id":"\/mapper\/domain.html#1-10-5","title":"1.10.5. Map From Persistence To Domain","content":"Most difficult, but with the best separation, is to map the individual parts of the persistence record over to a \"plain old PHP object\" (POPO) in the domain, perhaps something like the following:&lt;?php namespace App\\Domain\\Thread; use App\\DataSource\\Thread\\ThreadRecord; class Thread implements ThreadInterface { protected $id; protected $title; protected $body; protected $datePublished; protected $authorId; protected $authorName; protected $tags; protected $replies; public function __construct( $id, $title, $body, $datePublished, $authorId, $authorName, array $tags, array $replies ) { $this-&gt;id = $id; $this-&gt;title = $title; $this-&gt;body = $body; $this-&gt;datePublished = $datePublished; $this-&gt;authorId = $authorId; $this-&gt;authorName = $authorName; $this-&gt;tags = $tags; $this-&gt;replies = $replies; } public function getId() { return $this-&gt;id; } public function getTitle() { return $this-&gt;title; } public function getBody() { return $this-&gt;body; } public function getDatePublished() { return $this-&gt;datePublished; } public function getAuthorId() { return $this-&gt;authorId; } public function getAuthorName() { return $this-&gt;authorName; } public function getTags() { return $this-&gt;tags; } public function getReplies() { return $this-&gt;replies; } } Now the ThreadRepository::newThread() factory method has a lot of work to do. It needs to map the individual fields in the persistence record to the domain object properties.&lt;?php class ThreadRepository ... protected function newThread(ThreadRecord $record) { return new Thread( $record-&gt;thread_id, $record-&gt;title, $record-&gt;body, $record-&gt;date_published, $record-&gt;author-&gt;author_id, $record-&gt;author-&gt;name, $record-&gt;tags-&gt;getArrayCopy(), $record-&gt;replies-&gt;getArrayCopy() ); } Pros: Offers true separation of domain from persistence. Cons: Tedious and time-consuming to implement. "},{"id":"\/mapper\/domain.html#1-10-6","title":"1.10.6. Which Approach Is Best?","content":"\"It depends.\" What does it depend on? How much time you have available, and what kind of suffering you are willing to put up with.If you need something quick, fast, and in a hurry, implementing the domain interface in the persistence layer will do the trick. However, it will come back to bite in you just as quickly, as you begin to realize that you need different domain behaviors in different contexts, all built from the same backing persistence records.If you are willing to deal with the trouble that comes from depending on the persistence layer records inside your domain, and the possibility that other developers will expose the underlying record in subtle ways, then composing the record into the domain may be your best bet.The most formally-correct approach is to map the record fields over to domain object properties. This level of separation makes testing and modification of application logic much easier in the long run, but it takes a lot of time, attention, and discipline."},{"id":"\/skeleton\/getting-started.html#2-1","title":"2.1. Skeleton Generator","content":"This is the command-line interface package for Atlas. It is intended for use in your development environments, not your production ones."},{"id":"\/skeleton\/getting-started.html#2-1-1","title":"2.1.1. Installation","content":"This package is installable and autoloadable via Composer as atlas\/cli.Add it to the require-dev section of your root-level composer.json to install the atlas-skeleton command-line tool.{ \"require-dev\": { \"atlas\/cli\": \"~1.0\" } } "},{"id":"\/skeleton\/getting-started.html#2-1-2","title":"2.1.2. Creating Skeleton Classes","content":"You can create your data source classes by hand, but it's going to be tedious to do so. Instead, use the atlas-skeleton command to read the table information from the database.Create a PHP file to return an array of connection parameters suitable for PDO:&lt;?php \/\/ \/path\/to\/conn.php return [ 'mysql:dbname=testdb;host=localhost', 'username', 'password' ]; ?&gt; You can then invoke the skeleton generator using that connection. Specify a target directory for the skeleton files, and pass the namespace name for the data source classes. You can pass an explicit table name to keep the generator from trying to guess the name..\/vendor\/bin\/atlas-skeleton.php \\ --conn=\/path\/to\/conn.php \\ --dir=src\/App\/DataSource \\ --table=threads \\ App\\\\DataSource\\\\Thread  N.b.: The backslashes (\\) at the end of the lines are to allow the command to be split across multiple lines in Unix. If you are on Windows, omit the trailing backslashes and enter the command on a single line. That will create this directory and two classes in src\/App\/DataSource\/:\u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 Thread \u00c2\u00a0\u00c2\u00a0 \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 ThreadMapper.php \u00c2\u00a0\u00c2\u00a0 \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 ThreadTable.php The Mapper class will be empty, and the Table class will a description of the specified --table.Do that once for each SQL table in your database.If you pass --full to atlas-skeleton, it will additionally generate empty MapperEvents, Record, RecordSet, and TableEvents classes. (These are useful only if you want to add custom behaviors.)"}]